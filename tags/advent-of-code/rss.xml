<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Advent of Code on C&#39;est la Z</title>
    <link>https://cestlaz.github.io/tags/advent-of-code/</link>
    <description>C&#39;est la Z (Advent of Code)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 02 Dec 2022 13:59:06 -0400</lastBuildDate>
    
    <atom:link href="https://cestlaz.github.io/tags/advent-of-code/rss.xml" rel="self" type="application/rss" />
    
    
    <item>
      <title>Advent of Code 2022</title>
      <link>https://cestlaz.github.io/post/advent-2022-day01-01/</link>
      <pubDate>Fri, 02 Dec 2022 13:59:06 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2022-day01-01/</guid>
      <description>
&lt;p&gt;
It&amp;#39;s &lt;a href=&#34;https://adventofcode.com/&#34;&gt;Advent of Code&lt;/a&gt; season again. Every day a new two part programming
challenge and once again I&amp;#39;m taking part. At least until grading and
other end of term obligations end up eating my lunch.&lt;/p&gt;
&lt;p&gt;
I wasn&amp;#39;t planning on writing anything up but the first two days looked
like nice problems for CS1 or even CS0 students and since my friend
Steve was &lt;a href=&#34;https://github.com/scerruti/AoC2022&#34;&gt;writing up&lt;/a&gt; his take, I thought I&amp;#39;d at least comment on the
first two.&lt;/p&gt;
&lt;p&gt;
I also recorded a code through in Clojure which you can find at the
bottom of this post.&lt;/p&gt;
&lt;p&gt;
Even though I&amp;#39;m using Clojure, a similar approach can be taken in
languages like Python or Javascript. If you enjoy this type of
analysis please read Steve&amp;#39;s &lt;a href=&#34;https://github.com/scerruti/AoC2022&#34;&gt;posts&lt;/a&gt;. His approach is usually different
from mine as he&amp;#39;s working in Java and so is more OOP centric. I love
it when you can think about problems in different ways.&lt;/p&gt;
&lt;div id=&#34;outline-container-headline-1&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-1&#34;&gt;
Day 1 - Calorie Counting
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-1&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
Problem link: &lt;a href=&#34;https://adventofcode.com/2022/day/1&#34;&gt;&lt;a href=&#34;https://adventofcode.com/2022/day/1&#34;&gt;https://adventofcode.com/2022/day/1&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
Here the input was lines of numbers with an extra blank linke
separating sets of inputs:&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
1000
2000
3000

4000

5000
6000

7000
8000
9000

10000
&lt;/pre&gt;
&lt;p&gt;
Here, the first three numbers (1000,2000,3000) represent what the
first elf is carrying, 4000 the second elf, 5000, and 6000 the third,
etc..&lt;/p&gt;
&lt;p&gt;
The challenge was to figure out which elf carried the most.&lt;/p&gt;
&lt;p&gt;
A first year student might read a line at a time building a
sum. Whenever you see a blank line, see if that&amp;#39;s your largest sum so farand
if so, make a not of it.&lt;/p&gt;
&lt;p&gt;
In Python:&lt;/p&gt;
&lt;div class=&#34;src src-text&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;sum = 0
bigsum  = 0
for line in open(&amp;#34;../data/day01.dat&amp;#34;).readlines():
    if line == &amp;#34;\n&amp;#34;:
        if sum &amp;gt; bigsum:
            bigsum = sum
        sum = 0
        continue
    sum = sum + int(line)

print(bigsum)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Another approach, the one I used, was to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Convert the input lines into a list by splitting on double newlines&lt;/li&gt;
&lt;li&gt;Convert each list item into a list of numbers&lt;/li&gt;
&lt;li&gt;Sum each list&lt;/li&gt;
&lt;li&gt;Find the largest&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The video below shows this in Clojure, but in Python it might look
like this:   &lt;/p&gt;
&lt;div class=&#34;src src-text&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;input = open(&amp;#34;../data/day01.dat&amp;#34;).read().strip().split(&amp;#34;\n\n&amp;#34;)
input = [x.split(&amp;#34;\n&amp;#34;) for x in input]
int_input = [ [int(x) for x in sublist] for sublist in input]
sums = [ sum(x) for x in int_input]
max(sums)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
The nice thing here from the teaching point of view is that these
represent two very different approaches and there are probably more.&lt;/p&gt;
&lt;p&gt;
For part 2 you just had to add up the three largest elf loads. If you
used the second approach, instead of finding the largest number, you
can just sort the list and add up the biggest three.&lt;/p&gt;
&lt;p&gt;
The code for all of this in Clojure can be found &lt;a href=&#34;https://github.com/zamansky/advent2022/blob/main/src/day01.clj&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-2&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-2&#34;&gt;
Day 2 - Rock Paper Scissors
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-2&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
Day 2 was a rock paper scissors problem. Input was a list of &amp;#34;moves:&amp;#34;&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
A Y
B X
C Z
&lt;/pre&gt;
&lt;p&gt;
The above says that in move 1, your opponent played &amp;#34;A&amp;#34; and you played
&amp;#34;Y,&amp;#34; in move two, your opponent &amp;#34;B&amp;#34; and you &amp;#34;X,&amp;#34; etc.&lt;/p&gt;
&lt;p&gt;
The moves meant:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Opponent Letter&lt;/th&gt;
&lt;th&gt;Your letter&lt;/th&gt;
&lt;th&gt;Means&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;Rock&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Paper&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;Scissors&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
Each turned was scored as follows:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Result&lt;/th&gt;
&lt;th class=&#34;align-right&#34;&gt;Points&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;You win&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;You tie&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;You lose&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
Your score for a turn was the results points plus a 1 if you played
Rock, 2 if you played Paper, and 3 if you played Scissors.&lt;/p&gt;
&lt;p&gt;
The part 1 solution had you tracing through a game and figuring out
the score.&lt;/p&gt;
&lt;p&gt;
What&amp;#39;s nice about this problem is that it can be solved by a very raw
beginner with a not too long set of if statements.&lt;/p&gt;
&lt;p&gt;
You can also, however, look at more interesting approaches. &lt;/p&gt;
&lt;p&gt;
First, a student might notice that the moves are &amp;#34;in order&amp;#34; in that
each letter, or move, loses to the one after it. That is, Rock loses
to Paper, Paper loses to scissors, and wrapping around, scissors loses
to rock.&lt;/p&gt;
&lt;p&gt;
Then, they might see that they can assign a numeric value to each
move:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Opponent Letter&lt;/th&gt;
&lt;th&gt;Your letter&lt;/th&gt;
&lt;th&gt;Means&lt;/th&gt;
&lt;th class=&#34;align-right&#34;&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;Rock&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Paper&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;Scissors&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
Finally, they might notice that if they find the difference between
your move and your opponent&amp;#39;s move, you&amp;#39;ll get:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&#34;align-right&#34;&gt;Difference&lt;/th&gt;
&lt;th&gt;result&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&#34;align-right&#34;&gt;0&lt;/td&gt;
&lt;td&gt;tie - same move&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&#34;align-right&#34;&gt;1&lt;/td&gt;
&lt;td&gt;You win - you&amp;#39;re the &amp;#34;next&amp;#34; move&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&#34;align-right&#34;&gt;2&lt;/td&gt;
&lt;td&gt;You lose&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
You can also either deal with mod to wrap around or you can put in a
couple of negative values for the difference on your chart.&lt;/p&gt;
&lt;p&gt;
For part 1, my solution basically did what I just described. Make a
look up table to map the letters to values, find the difference, then
look up the points awarded from another look up table.&lt;/p&gt;
&lt;p&gt;
The Clojure code can be found &lt;a href=&#34;https://github.com/zamansky/advent2022/blob/main/src/day02.clj&#34;&gt;here&lt;/a&gt; and the video is embedded below.&lt;/p&gt;
&lt;p&gt;
For part 2, things were a bit tricker but also more interesting. Now,
your &amp;#34;move&amp;#34; of X,Y, or Z didn&amp;#39;t mean Rock, Paper or Scissors. The
letters now said that depending on your letter you had to select a
move so that you would either win, lose or draw based on this table:&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Your letter&lt;/td&gt;
&lt;td&gt;Choose a move that results in&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;You losing&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;A tie&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;You win&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
This part was a reduction - look at your letter and figure out what to
replace it with - A, B, or C based on the above chart and then just do
what you did in part 1.&lt;/p&gt;
&lt;p&gt;
Here, we notice that we tie if we choose the same move as our
opponent, we win if we choose the &amp;#34;next&amp;#34; move and we loose if we
choose the move that&amp;#39;s two away (mod 3 to deal with the wraparound).&lt;/p&gt;
&lt;p&gt;
The clojure code also &lt;a href=&#34;https://github.com/zamansky/advent2022/blob/main/src/day02.clj&#34;&gt;here&lt;/a&gt; and the walkthrough below.&lt;/p&gt;
&lt;p&gt;
Hope you all enjoyed this.&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/80so4H3mSCM&#34; title=&#34;YouTube video player&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Transparent Origami - Advent 2021 Day 13</title>
      <link>https://cestlaz.github.io/post/advent-2021-day13/</link>
      <pubDate>Mon, 13 Dec 2021 13:28:28 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2021-day13/</guid>
      <description>&lt;p&gt;
No post so far on &lt;a href=&#34;https://adventofcode.com/2021/day/12&#34;&gt;day 12&lt;/a&gt;. I finished part 1 but my code was pretty
messy which turned part 2 into a mess. I still have to go back to get
that second star so just like day 10, my day 12 write up is on hold.&lt;/p&gt;
&lt;p&gt;
That said, I really enjoyed [[&lt;a href=&#34;https://adventofcode.com/2021/day/13&#34;&gt;https://adventofcode.com/2021/day/13&lt;/a&gt;
][today&amp;#39;s]] challenge. Paper foldind. You&amp;#39;re given transparent paper with
a bunch of marks on it. You have to fold the paper over horizontal or
vertical lines and examine the results.&lt;/p&gt;
&lt;p&gt;
Input was in the form of lines x,y pairs followed by lines specifying
the folds.&lt;/p&gt;
&lt;p&gt;
First decision - data representation. Since we&amp;#39;ve got a grid,
temptation would be to use a 2D structure like a 2D array but there
are two problems. One is that each fold will make the paper smaller
and smaller which makes a 2D array wasteful if not clumsy. The other
issue is that we don&amp;#39;t know the ranges for our coordiates. We know
that all the values will be positive but we have no idea where they
start and end.&lt;/p&gt;
&lt;p&gt;
Just like with the cellular automaton, I decided to use a dictionary
where the key was  the x,y pair and the entry was the mark. I could
have used a plain list for the points but the dictionary gave me quick
lookup. Also, if part 2 had us change the marks based on if they
overlap after a fold, I&amp;#39;d be prepared.&lt;/p&gt;
&lt;p&gt;
For convenience (and as I learned later, part 2) I also wanted a
routine that could print the board. Here&amp;#39;s that routine in case you
want to see some clojure.&lt;/p&gt;
&lt;div class=&#34;src src-clojure&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;board-&amp;gt;string [board]
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;[maxx (apply max (map first (keys board))) &lt;span style=&#34;color:#75715e&#34;&gt;;; find the largest x&lt;/span&gt;
          maxy (apply max (map second (keys board))) &lt;span style=&#34;color:#75715e&#34;&gt;;; find the largest y&lt;/span&gt;
          k (keys board)

          &lt;span style=&#34;color:#75715e&#34;&gt;;; The next line makes a vector of maxy vectors&lt;/span&gt;
          &lt;span style=&#34;color:#75715e&#34;&gt;;; each of which has maxx spaces&lt;/span&gt;
          &lt;span style=&#34;color:#75715e&#34;&gt;;; basically a vector of vectors or 2D matrix if you would&lt;/span&gt;
          grid (into [] (repeat (inc maxy) (into [] (repeat (inc maxx) &lt;span style=&#34;color:#e6db74&#34;&gt;\ &lt;/span&gt;))))

          &lt;span style=&#34;color:#75715e&#34;&gt;;; go through the keys to our board (which is a hash table&lt;/span&gt;
          &lt;span style=&#34;color:#75715e&#34;&gt;;; and mark those squares with a #&lt;/span&gt;
          filled-grid (reduce (&lt;span style=&#34;color:#66d9ef&#34;&gt;fn &lt;/span&gt;[b [y x]] (&lt;span style=&#34;color:#a6e22e&#34;&gt;assoc-in&lt;/span&gt; b [x y] &lt;span style=&#34;color:#e6db74&#34;&gt;\#&lt;/span&gt;)) grid k)

          &lt;span style=&#34;color:#75715e&#34;&gt;;; change each line from a vector to a string&lt;/span&gt;
          &lt;span style=&#34;color:#75715e&#34;&gt;;; but leave the overall thing a vector since&lt;/span&gt;
          &lt;span style=&#34;color:#75715e&#34;&gt;;; it looks fine when I print it.&lt;/span&gt;
          string-grid (map &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(apply str %) filled-grid)
          ]
      string-grid
      ))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Once we have our &amp;#34;board&amp;#34; we can then deal with folding. Folds had to
be over a horizontal (ex: y=7) or vertical (ex: x=5).&lt;/p&gt;
&lt;p&gt;
It was important to note that since we&amp;#39;re folding we only want to take
the points with coordinates greater than the folding line and
transform those and not just transform all the points.&lt;/p&gt;
&lt;p&gt;
The actual transformation is pretty straightforward. Given the line&amp;#39;s
coordinate L the new point value can be calculated using:&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
newcoord = oldcoord - 2 * abs(oldcoord-L)
&lt;/pre&gt;
&lt;p&gt;
We just go through the points and if they have to be transformed,
update them.&lt;/p&gt;
&lt;p&gt;
Part 1 solved.&lt;/p&gt;
&lt;p&gt;
Part 2 turned out to be far easier than I expected. Part 1 had us just
do the first fold. Part 2 had us do all of them at which point, if we
printed our board it would show us the 8 secret letters that formed
our anwer. Since the example on the problem page was a y fold and the
first fold of my data was an x fold I knew both my folds worked. I
just ran through all the folds and voila.&lt;/p&gt;
&lt;p&gt;
Now, I&amp;#39;m not complaining about an easy problem. If it were harder I
might not finish and then no write up but I was expecting something
more.&lt;/p&gt;
&lt;p&gt;
There were ways to make part two a bit more complex. I could see maybe
placing the data so far off the end so that you had to translate them
down closer to the origin so that your result would print or maybe do
something with overlapping marks when you fold as I mentioned up top.&lt;/p&gt;
&lt;p&gt;
Still, nothing wrong with an easy day mixed in and I still think it&amp;#39;s
a great problem. This could be done by a CS0 or CS1 class. What I
particularly love about problems like this is that when you
ultimately solve it you &amp;#34;decode&amp;#34; a secret message. Much cooler than
just getting some number.&lt;/p&gt;
&lt;p&gt;
So, over half way done. I still have that part 2 of day 12 to finish
but still captured half the total stars for the event. That&amp;#39;s my
starting goal each year.&lt;/p&gt;
&lt;p&gt;
If you want to see my full solution, you can check it out &lt;a href=&#34;https://github.com/zamansky/advent2021/blob/main/src/day13.clj&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
Enjoy.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dumbo Octopus and the Game of Life - AOC 2011 Day 11</title>
      <link>https://cestlaz.github.io/post/advent-2021-day11/</link>
      <pubDate>Sat, 11 Dec 2021 11:31:32 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2021-day11/</guid>
      <description>&lt;p&gt;
I wasn&amp;#39;t particularly motivated to start &lt;a href=&#34;https://adventofcode.com/2021/day/11 &#34;&gt;day 11&lt;/a&gt; but took a look over
coffee. A grid of points where on each turn or step the points are
modified by some rule. Hey, this sounds familiar - cellular automata
like Conway&amp;#39;s Game of Life.&lt;/p&gt;
&lt;p&gt;
You set up your grid and then on each turn just follow the rules. In a
traditional Cellular Automaton like &lt;a href=&#34;https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life&#34;&gt;Conway&amp;#39;s Game of Life&lt;/a&gt;, on each
turn each cell looks at its six neighbors and makes a decision as to
its next state based on the neighbors and a rule.&lt;/p&gt;
&lt;p&gt;
For &lt;a href=&#34;https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life&#34;&gt;Conway&amp;#39;s Game of Life&lt;/a&gt;, a cell is either alive or dead. On each
turn, it counts all it&amp;#39;s neighbors and then decides if it will be
alive or dead next turn based on its current state and how many
neithbors are currently alive.&lt;/p&gt;
&lt;p&gt;
I love talking about Cellular Automata in class although I haven&amp;#39;t
done it since my Stuy days. One of my favorite topics is using CS to
solve a maze in NetLogo. I wrote about that &lt;a href=&#34;https://cestlaz.github.io/posts/2016-01-17-maze-ca/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
Cellular Automata is also not a stranger to Advent of Code with three
problems being CS problems in 2020 and I think there were more in
earlier years.&lt;/p&gt;
&lt;p&gt;
This year the twist was that the rule for each step had two stages and
the second stage could repeat over and over again.&lt;/p&gt;
&lt;p&gt;
The first stage was just to increment the value of each cell. The
second involved &amp;#34;flashing.&amp;#34; This would happen if a cell&amp;#39;s value
exceeded nine. If a cell flashed, it would increment the value of each
of its neighbors. This could cause a cascade by having a neighbor&amp;#39;s
value exceed nine. This kept going until the board stabalized. You
also had to account for the fact that a cell should only flip at most
once per step.&lt;/p&gt;
&lt;p&gt;
Part one had you calculate the number of flashes over the course of
100 steps.&lt;/p&gt;
&lt;p&gt;
When I do CA in a class like APCS-A we usually use a 2D array to
represent our world. In NetLogo, the world is already a grid. Since
I&amp;#39;m using Clojure, I though a hash table would be easier. The keys are
x,y coordinates and the values are the state of the cell (the integer
value). To set things up I stole the code from my code from last year,
also coincidentally &lt;a href=&#34;https://github.com/zamansky/advent2020/blob/main/src/day11.clj&#34;&gt;day 11&lt;/a&gt;. My &lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-day11/&#34;&gt;write up&lt;/a&gt; also talke about using a hash
table or dictionary instead of a 2D array.&lt;/p&gt;
&lt;p&gt;
The first stage of each step was easy. Just map the increment function
across the entire board.&lt;/p&gt;
&lt;p&gt;
The second step took more thought. First, I went through the board and
for any cell that was greater than 9 I incremented all its
neighbors. Then to make sure I don&amp;#39;t flash a cell more than once a
turn, I marked the current cell as being flashed. I did this by making
it a large negative number.&lt;/p&gt;
&lt;p&gt;
I repeated that second step over and over until it stabilized. That
is, you went through an iteration where the board didn&amp;#39;t change - no
new flashes.&lt;/p&gt;
&lt;p&gt;
Finally, I set all the negative cells, which indicated they flashed to
zero in preparation for the next step.&lt;/p&gt;
&lt;p&gt;
In the loop I counted and added up how many flashes we had and that
was part 1.&lt;/p&gt;
&lt;p&gt;
For part 2 you were looking for a step where every cell flashed at the
same time. This was pretty easy because we were able to essentially
use the same engine. The only difference was that instead of doing 100
steps, you kept going until every cell flashed in one turn. That
turned out to be easy to check. You know that happened when all of the
cells at the start of a turn are 0.&lt;/p&gt;
&lt;p&gt;
As usual, the full solution can be found on &lt;a href=&#34;https://github.com/zamansky/advent2021/blob/main/src/day11.clj&#34;&gt;GitHub.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
Wasn&amp;#39;t motivated to start today but it turned out to be a fun little
challenge.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bracket Bonanza (AOC 2021 day 10)</title>
      <link>https://cestlaz.github.io/post/advent-2021-day10/</link>
      <pubDate>Fri, 10 Dec 2021 12:15:34 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2021-day10/</guid>
      <description>&lt;p&gt;
I know, where&amp;#39;s day 9? Thursdays (and Mondays) are already tight for
me - I teach all morning and it&amp;#39;s been a rough week. I just had very
little energy and focus all day yesterday. I snuck some time in to
finish part 1 but couldn&amp;#39;t focus on part 2.&lt;/p&gt;
&lt;p&gt;
Today, however, my body gave me an extra half hour of sleep (til
4:30am) so I had extra time and energy. I was fortunate in that
today&amp;#39;s problem was essentially one that I&amp;#39;ve assigned time and time
again so I was able to wrap it up quickly and then go back to finish
day 9.&lt;/p&gt;
&lt;p&gt;
It&amp;#39;s pretty likely that there&amp;#39;ll be a day I can&amp;#39;t solve in the near
future so maybe I&amp;#39;ll write up day 9 then.&lt;/p&gt;
&lt;p&gt;
But for now, &lt;a href=&#34;https://adventofcode.com/2021/day/10&#34;&gt;day 10 - Syntax Scoring&lt;/a&gt; or as I like to say a bracket
bonanza. Inputs were lines of brackets like this:&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
[({(&amp;lt;(())[]&amp;gt;[[{[]{&amp;lt;()&amp;lt;&amp;gt;&amp;gt;
&lt;/pre&gt;
&lt;p&gt;
Both parts of the problem involve figuring out if the line is valid,
that is, if each open bracket has a matching close bracket without
overlap. For example (([])) is valid but (([)]) is not becaue the
inner () and the [] overlap.&lt;/p&gt;
&lt;p&gt;
I could be like a kid doing a technical interview and pretend I hadn&amp;#39;t
solved the problem before the interview but the truth is, I&amp;#39;ve
done problems very similar to this most times I teach data structures.&lt;/p&gt;
&lt;p&gt;
As you process through the input, whenever you see a closing bracket,
it &lt;strong&gt;has&lt;/strong&gt; to match up with the last seen open bracket otherwise the
expression is invalid. This means you have to maintain a data
structure in such a way that the last open bracket you see is the
first one you check whenever you see a closing brace.&lt;/p&gt;
&lt;p&gt;
This is, by definition, a stack. A stack is a data structure where the
last item you put in is the first item you take out.&lt;/p&gt;
&lt;p&gt;
So, the algorithm is pretty simple.&lt;/p&gt;
&lt;div class=&#34;src src-text&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;make an empty stack
For each character in the input:
  1. If it&amp;#39;s an open bracket put it on the stack
  2. If it&amp;#39;s a close bracket, check the top of the stack.
     1. If the stack is empty you&amp;#39;ve got an invalid expression - exit
     2. If top of the stack doesn&amp;#39;t match your bracket - invalid -exit
     3. If top of the stack does match your braket, pop it off the stack and keep going&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
That&amp;#39;s basically it. The only remaining task is to figure out the
specifics to answer the problem.&lt;/p&gt;
&lt;p&gt;
For part 1 you had to run the above algorithm on each line of input
and for each invalid expression look up the invalid character&amp;#39;s value
(provide in the problem text) and add them all up.&lt;/p&gt;
&lt;p&gt;
For part two you had to take the remaining characters in the lines
once you hit an invalid brace and figure out a slightly more complex
score.&lt;/p&gt;
&lt;p&gt;
So, given that I had basically done this problem it wasn&amp;#39;t hard but it
was fun. This could be directly assigned to any data structures class.&lt;/p&gt;
&lt;p&gt;
As usual, my code can be found here:
&lt;a href=&#34;https://github.com/zamansky/advent2021/blob/main/src/day10.clj&#34;&gt;&lt;a href=&#34;https://github.com/zamansky/advent2021/blob/main/src/day10.clj&#34;&gt;https://github.com/zamansky/advent2021/blob/main/src/day10.clj&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Seven Segment Silliness - Advent 2021 Day08</title>
      <link>https://cestlaz.github.io/post/advent-2021-day08/</link>
      <pubDate>Wed, 08 Dec 2021 13:20:49 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2021-day08/</guid>
      <description>&lt;p&gt;
Day 8 took a lot longer than the other days. Not all that much code
and not too complex, at least after getting through a scary sounding
lead up but going from problem statement to solution took both time
and thought.&lt;/p&gt;
&lt;p&gt;
As I started to read the problem, I wasn&amp;#39;t sure I&amp;#39;d finish it let
alone have time to write it up.&lt;/p&gt;
&lt;p&gt;
Take a minute to read over the problem. You can find it [[&lt;a href=&#34;https://adventofcode.com/2021/day/8&#34;&gt;https://adventofcode.com/2021/day/8&lt;/a&gt;
][here.]]&lt;/p&gt;
&lt;p&gt;
A pretty intimidating wall of text. &lt;/p&gt;
&lt;p&gt;
You&amp;#39;ve got a bunch of lines, each looking like this:&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
be cfbegad cbdgef fgaecd cgeb fdcge agebfd fecdb fabcd edb | fdgacbe cefdb cefbgd gcbe
&lt;/pre&gt;
&lt;p&gt;
Each &amp;#34;word&amp;#34; represents a seven segment display. The side to the left
of the | is the input for that line and the stuff on the right, the
output.&lt;/p&gt;
&lt;p&gt;
The problem is that each line has the inputs scrambled. We jave to
figure out which letter maps to the top segment, which the bottom,
etc.&lt;/p&gt;
&lt;p&gt;
Oh boy.&lt;/p&gt;
&lt;p&gt;
It turns out that part one really wasn&amp;#39;t hard at all. In fact, it
could make a nice early CS assignment. If you look at the display for
a &lt;strong&gt;1&lt;/strong&gt;, it has two segment on the right hand side. It&amp;#39;s the only number
that uses 2 and only 2 of the seven segments. Likewise a &lt;strong&gt;4&lt;/strong&gt; is the
only four segment letter, &lt;strong&gt;7&lt;/strong&gt; is the only one that uses 3 segments,
and &lt;strong&gt;8&lt;/strong&gt; is the only one that uses all seven segments.&lt;/p&gt;
&lt;p&gt;
For part 1 you just had to look at all the outputs  - that is, the
stuff on each line after the | and add up the number of items that
are either a 1, 4, 7, or 8. That&amp;#39;s easily accomplished by going over
each of those items and checking if they have the correct number of
characters and then figuring out the total number of these items.&lt;/p&gt;
&lt;p&gt;
I had already parsed my data into the a two item list where the left
item is a list of inputs and the right a list of outputs:&lt;/p&gt;
&lt;div class=&#34;src src-clojure&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;[ [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cg&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cdbga&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bcg&amp;#34;&lt;/span&gt; ...] [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;geac&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ceag&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;faedcb&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cg&amp;#34;&lt;/span&gt;]]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
So all I had to do go through all the output sides, count the characters in
each item and then add up the number of them.&lt;/p&gt;
&lt;p&gt;
Here&amp;#39;s the code:&lt;/p&gt;
&lt;div class=&#34;src src-clojure&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;  (&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;myfilter [x]
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;takes a list of numbers and returns only those that are 2,4,3, or 7&amp;#34;&lt;/span&gt;
    (filter &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(contains? &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;} %) x))


  (&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;part1 [  data]
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;[results (map second data) &lt;span style=&#34;color:#75715e&#34;&gt;;; pull out all the outputs&lt;/span&gt;
          counted (map &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(map count %) results) &lt;span style=&#34;color:#75715e&#34;&gt;;; turn the &amp;#34;words&amp;#34; into counts of their lengths&lt;/span&gt;
          f (map &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;myfilter&lt;/span&gt; %) counted) &lt;span style=&#34;color:#75715e&#34;&gt;;; only keep the ones that are the right lengths&lt;/span&gt;
          total (map &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(count %) f) &lt;span style=&#34;color:#75715e&#34;&gt;;; count how many are in each line&lt;/span&gt;
          ]
      (apply +  total))) &lt;span style=&#34;color:#75715e&#34;&gt;;; add them all up &lt;/span&gt;

  (&lt;span style=&#34;color:#a6e22e&#34;&gt;part1&lt;/span&gt; data)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
For part 2 we had to decode all the output lines and then turn them
into numbers and add them up.&lt;/p&gt;
&lt;p&gt;
Sounded really daunting. It required some thought but it wasn&amp;#39;t that
bad.&lt;/p&gt;
&lt;p&gt;
I wanted to build a dictionary where the keys were the digits and the
values would be the segments for that particular input line that
represent  that digit.&lt;/p&gt;
&lt;p&gt;
For a given line, we can do it pretty easily for the unique numbers 2,
4,3, and 7 so we just loop through all the items in a line  and when
we see an item with the appropriate length, we store the number in our
dictionary.&lt;/p&gt;
&lt;p&gt;
We might have something like this:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&#34;align-right&#34;&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&#34;align-right&#34;&gt;1&lt;/td&gt;
&lt;td&gt;b e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&#34;align-right&#34;&gt;4&lt;/td&gt;
&lt;td&gt;b c e g&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&#34;align-right&#34;&gt;7&lt;/td&gt;
&lt;td&gt;b d e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&#34;align-right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;a b c d e f g&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
These were the values from the first line of the example data. Also, I
used a Clojure set  to store the values since that makes the rest of
the solution easier.&lt;/p&gt;
&lt;p&gt;
I then took this dictionary and tried to add to it by figuring out the
5 segment numbers - specifically, 2, 3 and 5. It turns out that of the
5 segment numbers, the &lt;strong&gt;3&lt;/strong&gt; is the only one that ovelaps with the two
segments from the &lt;strong&gt;1&lt;/strong&gt; so we can find that one pretty easily. If the
five segment number wasn&amp;#39;t a 3, I looked to see if it was a 5. For
this, I looked to see if it had the left and middle segments that the
4 had. Finally, if it wasn&amp;#39;t a &lt;strong&gt;3&lt;/strong&gt; or a &lt;strong&gt;5&lt;/strong&gt; then it had to be a &lt;strong&gt;2&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;
Next, I did the same for the remaining segments which were all 6
segments. You can look at my full code (linked below) for specifics.&lt;/p&gt;
&lt;p&gt;
Once we had the complet dictionary I flipped it - keys became values
and values became keys so we could look up the output numbers. From
there, it was easy to convert them to numbers and find the final
answer.&lt;/p&gt;
&lt;p&gt;
The part of this problem that was both fun and challenging was trying
to figure out how to decode a given letter given what you already
figured out. That took some time but getting the final answers for
problems like this are somehow more satisfying than just a straight up
&amp;#34;code it&amp;#34; problem.&lt;/p&gt;
&lt;p&gt;
You can find my full solution &lt;a href=&#34;https://github.com/zamansky/advent2021/blob/main/src/day08.clj&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
I was worried I wasn&amp;#39;t going to finished this one when I first read it
but I think it&amp;#39;s my favorite of the year so far.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How you look at a problem can make it easier - AOC 2021 Day 7</title>
      <link>https://cestlaz.github.io/post/advent-2021-day07/</link>
      <pubDate>Tue, 07 Dec 2021 09:04:53 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2021-day07/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2021/day/7&#34;&gt;Today&amp;#39;s problem&lt;/a&gt; was similar to &lt;a href=&#34;https://cestlaz.github.io/post/advent-2021-day06/&#34;&gt;yesterday&amp;#39;s&lt;/a&gt; in that it&amp;#39;s ease or
difficulty really depended on how you looked at the question.&lt;/p&gt;
&lt;p&gt;
For yesterday, the problem was hard if you approached it by modeling
each and every lanternfish but it was much easier if you modeled the 8
days of the reproduction cycle. Sure, there was still work to be done
but looking at the problem the right way made things much easier.&lt;/p&gt;
&lt;p&gt;
Same thing for today, at least for me.&lt;/p&gt;
&lt;p&gt;
We were given a list of crabs and their locations and the challenge
was getting them all to the same spot. Fortunately, crabs in their
submarines can only move in one dimension - they can only move
horizontally. This gives us an input that&amp;#39;s just a list of integers,
each representing a crab location.&lt;/p&gt;
&lt;p&gt;
We want to move all the crabs to the same location and we want to do
it as efficiently as possible. The crab submarines use one unit of
fuel for each step taken so we want to minimize the overall amount of
fuel used.&lt;/p&gt;
&lt;p&gt;
If we look at this from the crab point of view this could seem
daunting - do we move the crabs one at a time? Do we have them
converge? Will we have to do some crazy recursive movement thing?&lt;/p&gt;
&lt;p&gt;
It turns out, none of the above. As soon as we realize that we don&amp;#39;t
have to figure out actual moves or actually move the crabs the problem
becomes much easier. It isn&amp;#39;t about the crabs but rather about the
locations. We want to figure out the minimal cost of moving all the
crabs to each location and then we can pick the lowest overall cost.&lt;/p&gt;
&lt;p&gt;
This turns out to be rather simple.&lt;/p&gt;
&lt;p&gt;
For each possible location (looping from smallest crab location to
larges):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;calculate the distance from each crab to this location.&lt;/li&gt;
&lt;li&gt;Add up all those distances.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We then just need to take the smallest distance and we&amp;#39;re done.&lt;/p&gt;
&lt;p&gt;
On to part two.&lt;/p&gt;
&lt;p&gt;
For part two, there was a change to the fuel cost. Instead of just
being the distance between the two locations, the cost of the fuel
increased by one for each step. So, for moving 1 step the cost would
be one. Two steps, 1+2, three 1+2+3 etc..&lt;/p&gt;
&lt;p&gt;
This was easy enough to model. I just changed the function that
calculated the old cost with one that calculated the new cost. To do
that, I took the difference between the two endpoints and calculated
the sum from 1 up to and including that number.&lt;/p&gt;
&lt;p&gt;
This added an additional loop but I figured might as well try it. It
was noticeably slower than part 1 - about 11 seconds as opposed to
around 90 msec but fast enough to get an answer and finish the problem
for the day. That said, it was easy enough to improve the solution if
you know that you can calculate the sum from 1 to n using the formula
(n*(n+1))/2. This got the speed back to just over 100 msec.&lt;/p&gt;
&lt;p&gt;
Looking over the adventofcode subreddit people were talking about
using the median to more quickly solve the problem but what I did was
good enough for me.&lt;/p&gt;
&lt;p&gt;
As always, the clojure code can be found &lt;a href=&#34;https://github.com/zamansky/advent2021/blob/main/src/day07.clj&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
Enjoy.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lanternfish and lots of data (AOC 2021 Day 6)</title>
      <link>https://cestlaz.github.io/post/advent-2021-day06/</link>
      <pubDate>Mon, 06 Dec 2021 16:25:24 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2021-day06/</guid>
      <description>&lt;p&gt;
Today we had to model the growth of the lanternfish population
(&lt;a href=&#34;https://adventofcode.com/2021/day/6&#34;&gt;problem here&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;
Lanternfish spawn new lanternfish every seven days. The trick is that
the original starting population consists of fish at different points
in the cycle. For instance, if your input data was 3,2,4 then each fish
would spawn a new fish in three, two, and four days respectively. The
new fish would set their timers to 8 and start counting down to their
spawn date on the next day and the original fish would reset it&amp;#39;s
timer to 6.&lt;/p&gt;
&lt;p&gt;
Of course, lanternfish never die so the population is going to get
quite large.&lt;/p&gt;
&lt;p&gt;
At first glance this seems to be an easy problem to model. Read the
fish into a list or array and start processing them a day at a
time. Add fish to the end as needed.&lt;/p&gt;
&lt;p&gt;
I&amp;#39;m guessing this would work for part 1 but doubt it would work for
part 2. Even before I started solving this just seemed like a problem
where part 2 would blow away our data set getting much to large much
too fast.&lt;/p&gt;
&lt;p&gt;
So, what to do? It turns out the problem is cyclical. Instead of
looking at fish, we can look at days. We have an 8 day cycle. Instead
of storing the fish, store the number of fish that will spawn on any
given day.&lt;/p&gt;
&lt;p&gt;
That&amp;#39;s the insight.&lt;/p&gt;
&lt;p&gt;
I started by playing around with mod and trying to figure out how to
walk around the list while summing up fish but after a while my brain
started to hurt. Instead, I just did things in the most
straightforward way I could.&lt;/p&gt;
&lt;p&gt;
Fist, I made a list with my initial state. The example problem had a
data set of &lt;code&gt;&amp;#34;3,4,3,1 2&amp;#34;&lt;/code&gt; which led to this list:&lt;/p&gt;
&lt;div class=&#34;src src-clojure&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Notice that I have 9  not 8 slots (indexed 0 - 8). That extra one at
the end is where I move the fish that are spawning today (day 0) so
they can start the cycle again.&lt;/p&gt;
&lt;p&gt;
From there, it&amp;#39;s just following the rules:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Grab the number of fish to spawn today.&lt;/li&gt;
&lt;li&gt;Move all the fish down a day - that is, the fish in day 1 go to day
0, day 2 to day 1 etc.&lt;/li&gt;
&lt;li&gt;Add the new fish to slot 6 (as per the specification).&lt;/li&gt;
&lt;li&gt;Add the number that spawned today to the end.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
Repeat this for the requisite number of days and then add them all up.&lt;/p&gt;
&lt;p&gt;
The Clojure code for the complete solution is:&lt;/p&gt;
&lt;div class=&#34;src src-clojure&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;      (&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;solve [data days]
        (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;[start-state (&lt;span style=&#34;color:#a6e22e&#34;&gt;reduce&lt;/span&gt;
                           (&lt;span style=&#34;color:#66d9ef&#34;&gt;fn &lt;/span&gt;[sofar next]
                             (&lt;span style=&#34;color:#a6e22e&#34;&gt;update&lt;/span&gt; sofar next inc))
                           [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; ] data )]
          (apply + (&lt;span style=&#34;color:#66d9ef&#34;&gt;loop &lt;/span&gt;[i &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
                          gens start-state]
                     (&lt;span style=&#34;color:#66d9ef&#34;&gt;if &lt;/span&gt;(&amp;lt; i days)
                       (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;[last (first gens)
                             gens  (into []  ( drop &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; gens))
                             gens  (assoc gens &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; (+ (nth gens &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;) last))
                             gens  (conj gens last)
                             ]
                         (&lt;span style=&#34;color:#a6e22e&#34;&gt;recur&lt;/span&gt; (inc i) gens)
                         )
                       gens)))))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
For those of you not familiar with Clojure, that &lt;code&gt;reduce&lt;/code&gt; in the let on the second line is how we take the data
and build our starting state. For those of you who DO know clojure, I
could probably have made it cleaner with a threading macro instead of
the three step assignment to gens in the bottom let.&lt;/p&gt;
&lt;p&gt;
In any event, we walk away with a memory efficient time efficient
solution.&lt;/p&gt;
&lt;p&gt;
There&amp;#39;s probably some recurrence that could be set up and solved to do
this all with math but since the mod stuff made my head hurt working
on a recurrence equation would probably make it explode.&lt;/p&gt;
&lt;p&gt;
There&amp;#39;s usually at least one problem like this in advent of code each
year. Something where it looks like you&amp;#39;ll have to calculate forever
but it turns out you can set up a short repeating cycle to get the job
done. Unfortunately, they&amp;#39;re all too advanced for my average intro CS
students. Sure, I could go over the problem and they&amp;#39;d kindof get it
but I don&amp;#39;t think the majority would really grok it. Alternatively
they could just follow the rules given and led in class to setting up
the cycle but I&amp;#39;d love to come up with one where they can really
discover the magic.&lt;/p&gt;
&lt;p&gt;
I should spend some time thinking about this.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>One man&#39;s complex is another man&#39;s simple (AOC 2021 Day 5)</title>
      <link>https://cestlaz.github.io/post/advent-2021-day05/</link>
      <pubDate>Sun, 05 Dec 2021 10:40:21 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2021-day05/</guid>
      <description>&lt;p&gt;
Yesterday I wrote about the virtues of a simple straightforward
solution as opposed to a super &amp;#34;clever&amp;#34; one. Today reminded me that
what seems simple to one person might be clever to another.&lt;/p&gt;
&lt;p&gt;
Having successfully survived bingo with a giant squid, Today&amp;#39;s
&lt;a href=&#34;https://adventofcode.com/2021/day/5&#34;&gt;challenge&lt;/a&gt; had us navigating our sub so as to avoid dangerous parts of
the ocean. We were given a bunch of lines represented by endpoints as
input. If we graphed all the lines, some of them would overlap. The
more the overlap, the more dangerous. Given all the points on the
graph that are covered by a line, we had to determine how many points
were covered by two or more lines.&lt;/p&gt;
&lt;p&gt;
For example, if we have the following 10x10 grid with 1,1 being the
upper left adn 10,10 the lower right and the following lines:&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
1,2 --&amp;gt; 8,2
3,1 --&amp;gt; 3,7
2,4 --&amp;gt; 7,4
6,1 --&amp;gt; 6,8
&lt;/pre&gt;
&lt;p&gt;
we&amp;#39;d have the following lines:&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
..X..X....
XXXXXXXX..
..X..X....
.XXXXXX...
..X..X....
..X..X....
.....X....
.....X....
..........
..........
&lt;/pre&gt;
&lt;p&gt;
If instead of X we marked each square with the number of times it was
drawn on we&amp;#39;d have&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
..1..1....
11211211..
..1..1....
.121121...
..1..1....
..1..1....
.....1....
.....1....
..........
..........
&lt;/pre&gt;
&lt;p&gt;
In the above example, the answer to part 1 would be 4 since 4 squares
have more than one line on them&lt;/p&gt;
&lt;p&gt;
Here our lines are all vertical and horizontal. For part 1 we only had
ton consider horizontal and vertical even though the input might
specify diagonals.&lt;/p&gt;
&lt;p&gt;
Part 2 required we also deal with diagonals but only the ones with a
45 degree angle.&lt;/p&gt;
&lt;p&gt;
For a relatively new programmer the obvious solution would be to
create a 2D array. Then you just have to scan through the data and
fill the array. Finally, go over the array and count the cells that
were hit more than once.&lt;/p&gt;
&lt;p&gt;
This approach presents three problems. The first, which is minor is
that you&amp;#39;d first have to scan the input to determine the required
array size. The second problem is that you could have negative values
in your input so you&amp;#39;d have to somehow compensate for that
possibility. Finally, you could have spares input. What if there were
only two lines but one was from -1000000,-1000000 –&amp;gt; -999999,999999
and the other from 1000000,1000000 –&amp;gt; 1000001,1000001. You have two
tiny lines but you&amp;#39;d need a HUGE array.&lt;/p&gt;
&lt;p&gt;
For me, an easier, simpler solution was to use a dictionary (also
called hash table, or map depending on language). My grid would start
as an empty map and then I&amp;#39;d add points by walking the line segments. For
example if I had a line from 0,0 –&amp;gt; 2,0, I&amp;#39;d add three entries to the
map. The keys would be (0,0), (1,0), and (2,0), and the values would
be all 1 since each location was hit once.&lt;/p&gt;
&lt;p&gt;
If I then added the line (1,0) –&amp;gt; (1,2), I&amp;#39;d end up with this final
map:&lt;/p&gt;
&lt;div class=&#34;src src-python&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;  {(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) : &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
   (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) : &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,
   (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) : &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
   (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) : &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
   (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) : &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Note that the (1,0) entry now has a two since it was hit twice.&lt;/p&gt;
&lt;p&gt;
Once we added all the lines, pull out the values and count how many
are greater or equal to two.&lt;/p&gt;
&lt;p&gt;
Once armed with this approach it was easy enough to solve the
problem. You can check out the code &lt;a href=&#34;https://github.com/zamansky/advent2021/blob/main/src/day05.clj&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
I&amp;#39;ll maintain that I used a simple, clear, and maintainable approach
but it&amp;#39;s also worth noting that if I presented this problem to
relative beginners, depending on what tools they&amp;#39;ve used, they might
very well lean heavily on an array representation. This would
certainly be true when I was a beginner - we never saw maps or
dictionaries until we built them in our data structures courses. Now,
with students cutting their teeth in languages like Python where
dictionaries come up much earlier, perhaps today&amp;#39;s beginners would
also opt for the map / dictionary solution.&lt;/p&gt;
&lt;p&gt;
In any event, I always like problems like this where there are
multiple ways of representing the data in the solution which leads to
some nice food for thought.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Working code is better than clever code (AOC 2021 day 4)</title>
      <link>https://cestlaz.github.io/post/advent-2021-day04/</link>
      <pubDate>Sat, 04 Dec 2021 12:17:30 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2021-day04/</guid>
      <description>&lt;p&gt;
I always tell my students that the cleverest program is
worthless if it doesn&amp;#39;t actually work.&lt;/p&gt;
&lt;p&gt;
There are always some kids in class that all too often try to write
the fanciest solutions.&lt;/p&gt;
&lt;p&gt;
They&amp;#39;re the ones that write&lt;/p&gt;
&lt;div class=&#34;src src-c&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;l&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;s){&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!*&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;(l(&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;s)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
instead of something like:&lt;/p&gt;
&lt;div class=&#34;src src-c&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;string_length&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;s){
  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (s[i] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;){
    i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; i;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
to calculate the length of a string.&lt;/p&gt;
&lt;p&gt;
They try to code in a way they envision a master programmer coding
which invariably leads them to hours of heartache and misery as they
try to fix a poorly and complexly designed system. When I was a kid I
did this as well but learned better early on. One thing I was pretty
proud of as a young professional programmer were the number of
comments I&amp;#39;d get from peers and superiors on the readability of my
work.&lt;/p&gt;
&lt;p&gt;
Of course, my view isn&amp;#39;t unique. Much more famously, Donald Knuth said
the same when he quipped that &amp;#34;premature optimization is the root of
all evil.&amp;#34;&lt;/p&gt;
&lt;p&gt;
So while today&amp;#39;s advent of code problem presented a number of design
choices, I decided to go lazy and simple. Sure, my solution&amp;#39;s probably
slower than others but it&amp;#39;s easy and understandable.&lt;/p&gt;
&lt;p&gt;
Today&amp;#39;s problem had you playing bingo against a giant squid (full
problem &lt;a href=&#34;https://adventofcode.com/2021/day/4&#34;&gt;here&lt;/a&gt;). The core was that after a number of numbers were drawn,
each time you crossing that number off your boards, you had to figure
out if a board was a winner.&lt;/p&gt;
&lt;p&gt;
First the input. It was easy enough to read in the file. The first
line were the bingo balls in the order they were to be drawn and then
you had a bunch of 5 line blocks, each line with 5 numbers
representing a 5x5 board. Each board was separated by a space.&lt;/p&gt;
&lt;p&gt;
My strategy was to read in all the boards into a list, then as I draw
each bingo ball, replace all occurrences of the number drawn in on the
boards with an X. Then, check to see if we have 5 X&amp;#39;s in a row either
vertically or horizontally.&lt;/p&gt;
&lt;p&gt;
Reading was easy but there were some decisions to be made. I was going
to have a list of boards but what should a board look like? I didn&amp;#39;t
want to use a 2D array since that&amp;#39;s not Clojure&amp;#39;s strong suit but I
could easily use a list of lists (or vector of vectors).&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
((22 13 17 11  0)
 ( 8  2 23  4 24)
 (21  9 14 16  7)
 (6 10  3 18  5)
 (1 12 20 15 19))
&lt;/pre&gt;
&lt;p&gt;
If I were coding in Python, I could do this as well using a list of lists.&lt;/p&gt;
&lt;p&gt;
This representation makes it &lt;strong&gt;very&lt;/strong&gt; easy to check to see if we have a winner
going across but checking vertically is a little annoying and doing
the substitutions is also annoying.&lt;/p&gt;
&lt;p&gt;
On the other hand, I could represent the board as a list of 25 items
and use a mapping function to get to a specific row,col location such
as &lt;code&gt;index = board[row*5+col]&lt;/code&gt; . This representation makes checking the
board for winners a little onerous but marking squares with an X
becomes trivial - just replace all occurrences of the number in
question with an X. This can be done in Clojure using map:&lt;/p&gt;
&lt;div class=&#34;src src-clojure&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;add-mark [board mark]
  (map &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;if &lt;/span&gt;(= % mark) &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;X&amp;#34;&lt;/span&gt; %) board))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Thinking about it, it was really easy to switch from the list of 25
items to the list of list representations. We can do this with the
Clojure partition function.&lt;/p&gt;
&lt;div class=&#34;src src-clojure&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;    (&lt;span style=&#34;color:#a6e22e&#34;&gt;partition&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;14&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;21&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt;))

    &lt;span style=&#34;color:#75715e&#34;&gt;;; results in:&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;;;((0 1 2 3 4)&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;;; (5 6 7 8 9 )&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;;; (10 11 12 13 14)&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;;; (15 16 17 18 19)&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;;; (20 21 22 23 24))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
So, we can use the 25 element list representation to mark the boxes
and then switch to the list of lists to check for a winner. What&amp;#39;s
better, we can transpose the list of lists, that is switch the rows
and columns so as to make the vertical check into a horizontal one.&lt;/p&gt;
&lt;p&gt;
Here&amp;#39;s my code to do all the checking:&lt;/p&gt;
&lt;div class=&#34;src src-clojure&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;has-five? [board]
  (&amp;gt;  (&lt;span style=&#34;color:#a6e22e&#34;&gt;-&amp;gt;&amp;gt;&lt;/span&gt; board
           (map &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(filter (&lt;span style=&#34;color:#66d9ef&#34;&gt;fn &lt;/span&gt;[x] (= x &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;X&amp;#34;&lt;/span&gt;))%)  ) &lt;span style=&#34;color:#75715e&#34;&gt;;; keep only the Xs&lt;/span&gt;
           (map count) &lt;span style=&#34;color:#75715e&#34;&gt;;; how many are there in each row&lt;/span&gt;
           (filter &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(= &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; % )) &lt;span style=&#34;color:#75715e&#34;&gt;;; keep the winners (5 in a row)&lt;/span&gt;
           count) &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;;; return true if we have any winners&lt;/span&gt;



(&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;check-board [board]
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;[horiz (&lt;span style=&#34;color:#a6e22e&#34;&gt;partition&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; board) &lt;span style=&#34;color:#75715e&#34;&gt;;; convert 1D board to a 2D one&lt;/span&gt;
        vert  (apply mapv vector horiz)] &lt;span style=&#34;color:#75715e&#34;&gt;;; transpose &lt;/span&gt;
    (or  (&lt;span style=&#34;color:#a6e22e&#34;&gt;has-five?&lt;/span&gt; horiz)
         (&lt;span style=&#34;color:#a6e22e&#34;&gt;has-five?&lt;/span&gt; vert))))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Now, solving part 1 was easy:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;take the next ball&lt;/li&gt;
&lt;li&gt;mark all the locations with the ball&amp;#39;s number&lt;/li&gt;
&lt;li&gt;see if there&amp;#39;s a winner&lt;/li&gt;
&lt;li&gt;If not, go back to step 1.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
Sure, we&amp;#39;re doing more transformations on the data than needed but
it&amp;#39;s clean and easy and at least from my point of view, made the whole
exercise much less error prone.&lt;/p&gt;
&lt;p&gt;
On to part 2.&lt;/p&gt;
&lt;p&gt;
Turns out that was also pretty simple. Instead of stopping at the
first winning board we had to find the last winning board.&lt;/p&gt;
&lt;p&gt;
Pretty easy. We just had to modify the above procedure to the
following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;take the next ball&lt;/li&gt;
&lt;li&gt;mark all the locations wiht the ball&amp;#39;s number&lt;/li&gt;
&lt;li&gt;remove any board that&amp;#39;s a winner&lt;/li&gt;
&lt;li&gt;If we&amp;#39;re down to one board remaining we&amp;#39;ve found the board&lt;/li&gt;
&lt;li&gt;If not, back to step 1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I did this but first got a wrong answer. After looking at my results I
realized that I stopped when I got down to 1 board but it hadn&amp;#39;t
necessarily won yet. I had to then continue drawing balls and marking
squares until that final board was solved.&lt;/p&gt;
&lt;p&gt;
That was it.&lt;/p&gt;
&lt;p&gt;
Upon later reflection, I realized my solution wasn&amp;#39;t perfect. It would
fail if there were some boards that were never solvable. This though
is an easy fix.&lt;/p&gt;
&lt;p&gt;
So, maybe not a super clever super fast solution but a clean one that
works and is easy to understand and modify. To me that&amp;#39;s the
definition of a great solution.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Work through the example!!!!!</title>
      <link>https://cestlaz.github.io/post/advent-2021-day03/</link>
      <pubDate>Fri, 03 Dec 2021 17:10:50 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2021-day03/</guid>
      <description>&lt;p&gt;
It&amp;#39;s that time of year again. Yep, you got it. Time for &lt;a href=&#34;https://adventofcode.com/&#34;&gt;Advent of
Code&lt;/a&gt;. I&amp;#39;m not feeling nearly as motivated as in past years but so far
so good. Finished the first three days.&lt;/p&gt;
&lt;p&gt;
Today I got a good reminder - work through your examples. You can find
today&amp;#39;s problem &lt;a href=&#34;https://adventofcode.com/2021/day/3&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
For part 1 you got a list of binary numbers and had to figure out how
many ones and zeros there were in any given digit.&lt;/p&gt;
&lt;p&gt;
For example, if we had these numbers:&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
0010
0111 
1001
1010
1111
&lt;/pre&gt;
&lt;p&gt;
The ones digit has 3 total ones and 2 zeros. The  2s digit has 4
ones and 1 zero. You then had to do some calculations based on if
there were more ones in a given column or more zeros.&lt;/p&gt;
&lt;p&gt;
Pretty straight forward. As usual, I&amp;#39;m working in Clojure so I used
map and reduce to figure out the number of ones in each column and
then did the required calculation. If you want to see the code, you
can find it &lt;a href=&#34;https://github.com/zamansky/advent2021/blob/main/src/day03.clj&#34;&gt;here&lt;/a&gt;. Later in the day I looked at other people&amp;#39;s
solutions and it was interesting in that a lot of people approached it
differently - they basically looked at the list of numbers and rotated
it so that columns became rows and rows became columns which then make
counting ones and zeros easier,  but I digress.&lt;/p&gt;
&lt;p&gt;
I then had to rush through part 2 because I had to leave for the
ophthalmologist. I didn&amp;#39;t know if my eyes were going to be dilated and
if they were, I wasn&amp;#39;t going to be able to come back to the problem
until late in the evening.&lt;/p&gt;
&lt;p&gt;
I got something done but unfortunately, didn&amp;#39;t quite
finish. Fortunately, my eyes weren&amp;#39;t dilated so after getting home I
set to finish the problem.&lt;/p&gt;
&lt;p&gt;
Part 2 involved taking your list of numbers, calculating some values
using the part 1 code and then using those values to eliminate some of
the numbers. You then repeated this process until you were left with a
single number. See the problem statement and if you want my solution
for details.&lt;/p&gt;
&lt;p&gt;
I got something working but my answer was incorrect. I spent, well,
frankly, too much time trying to figure out why. I was
stumped. Finally I went back to the example in the question and
actually worked through it (as opposed to glancing over it). I quickly
saw my error. I had calculated the part 1 values based on the original
data then kept applying those to the data list until it reduced to a
single number. I was supposed to recalculate the part 1 values on the
reduced data set each time instead. Once I realized this, it was a
pretty quick solution.&lt;/p&gt;
&lt;p&gt;
This isn&amp;#39;t the first time my carelessness cost me time. Back in 2016 I
spent way too long trying to fix an Advent of Code problem where the
problem was that I had the wrong parameters in a function (&lt;a href=&#34;https://cestlaz.github.io/posts/2015-12-17-im-an-idiot/&#34;&gt;link&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;
In this case, the moral of the story is &lt;strong&gt;work through the provided
examples!!!!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
So, that&amp;#39;s it for today. If you haven&amp;#39;t checked out Advent of Code, I
highly recommend it and if you want to see my solutions, however far I
get, you can find them &lt;a href=&#34;https://github.com/zamansky/advent2021&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
Finally, in the spirit of the season, Natan composed a new Chanukah
song.&lt;/p&gt;
&lt;p&gt;
If you&amp;#39;re so inclined, you can check it out below:&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/fatTWGfXO_o&#34; title=&#34;YouTube video player&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Final thoughts on Advent of Code 2020</title>
      <link>https://cestlaz.github.io/post/advent-2020-final-thoughts/</link>
      <pubDate>Sun, 27 Dec 2020 15:57:22 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-final-thoughts/</guid>
      <description>
&lt;p&gt;
Time for some final thoughts on &lt;a href=&#34;https://adventofcode.com/&#34;&gt;Advent of Code 2020&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;
This was my sixth Advent of Code but the first time I completed all 25
days. Better than last year&amp;#39;s 31 and a whole lot better than my
weakest effort of 11 stars in 2017. I managed to find the time to
finish all but two on the day they were released and finished those
two on Christmas morning. This was also the first year I wrote all my
solutions in Clojure and I also made a bunch of blog posts and videos
(linked on the bottom of this post).&lt;/p&gt;
&lt;p&gt;
From my point of view 2020 was the best AoC to date and I&amp;#39;m not just
saying that because I finished all the problems. Well, maybe I am but
it&amp;#39;s really because the content and release of content lent itself to
my completing all the problems.&lt;/p&gt;
&lt;p&gt;
Before jumping in to my specific commentary I want to remind readers
that anyone&amp;#39;s perceptions of an event like this will be biased. If
there&amp;#39;s an aspect that I particularly liked you can bet there&amp;#39;s
someone else out there who didn&amp;#39;t like it.&lt;/p&gt;
&lt;div id=&#34;outline-container-headline-1&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-1&#34;&gt;
Overall content
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-1&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
As usual a wide range of topics were covered including binary numbers,
pattern matching, simulation, dynamic programming, mathy stuff,
parsing, graph algorithms and more. &lt;/p&gt;
&lt;p&gt;
I didn&amp;#39;t find myself totally lost on any questions. There were some
problems that at least to me seemed to require graph algorithms and
one where dynamic programming or at least memoization was a boon but
for the most part it seemed that problems were indeed
approachable. Even the math day that had a bunch of reddit chatter
over the Chinese Remainder Theorem could be done without knowing about
the CRM. That was good because I had never heard of it (and if any of
the redditors who mentioned that it should  common knowledge, it
shouldn&amp;#39;t - I have an undergrad in CS and a Masters in CS along wit 30
years of teaching and this is the first time I&amp;#39;ve seen it). &lt;/p&gt;
&lt;p&gt;
In past years there always seemed to be a few problems that you needed
some preexisting knowledge to attempt. I had no problem with that - no
need to have  to finish all the problems and there&amp;#39;s nothing wrong
with hitting up reddit, learning something new and then tackling the
problem. This year it seemed that the problems more directly led to
the knowledge. I&amp;#39;ll talk about this more later. &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-2&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-2&#34;&gt;
Problem size
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-2&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
For the most part the problems were the perfect size for me. I&amp;#39;d read
the problems when I woke up, work on part 1 after my run and then part
2 later in the day - at least that was the ideal - bugs and life
sometimes got in the way. None of the problems required pages and
pages of code for the solutions which I liked. Problems were clever
and interesting but led to moderately sized solution. &lt;/p&gt;
&lt;p&gt;
In past years, the weekend problems were longer and/or harder. The
logic being that there&amp;#39;s more time to work on them. I never liked
that. AoC is great but it&amp;#39;s an add on. It&amp;#39;s an add on to work during
the week but it&amp;#39;s an add on to family time on the weekend. I liked
that this year the only weekend problem that was much larger and longer
was day 20 - the image reconstruction. &lt;/p&gt;
&lt;p&gt;
This is not to say that some problems didn&amp;#39;t take a good deal of time
but rather that once you had an approach you didn&amp;#39;t sit down and say
&amp;#34;oh man, now I have to write hundreds of lines of code to implement
this.&amp;#34;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-3&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-3&#34;&gt;
particularly nice problems 
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-3&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
In spite of my not finishing part 2 until the last day, I loved day
20 - Jurassic Jigsaw. It was a little long and I spend more time than
I care to admit on debugging a really silly error but I loved the
problem.&lt;/p&gt;
&lt;p&gt;
Why? &lt;/p&gt;
&lt;p&gt;
First, it had staged difficulty -&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Parse the data into a reasonable representation&lt;/li&gt;
&lt;li&gt;Do a partial edge matching for part 1 (not so hard)&lt;/li&gt;
&lt;li&gt;Do the harder / longer matching to reconstruct the image&lt;/li&gt;
&lt;li&gt;Remove the border and solve the problem.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Second, you actually discovered something - you &lt;strong&gt;found&lt;/strong&gt; sea
monsters!!!! You had a problem with an &amp;#34;unknown&amp;#34; solution and you
figured it out. Contrast that with say, day 2 where you just had to
validate passwords. That was also a fun problem but there was no big
reveal. It was really cool to decode your image and actaully find the
hidden monsters. &lt;/p&gt;
&lt;p&gt;
Day 16 and 21 allowed for similar discovery at the end but not quite
as cool. I liked 16 very much but had a hard time getting my head
around the example for 21. Still a cool problem.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-4&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-4&#34;&gt;
Teachable stuff
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-4&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
As usual, I found a lot that I liked as a teacher in AoC. I love that
many of the problems introduce problem solvers to new things. For me,
the Chinese Remainder Theorem was new even though I only discovered it
via the subreddit. Cellular Automata was prominently featured
this year, binary explicitly mentioned as was recursion. &lt;/p&gt;
&lt;p&gt;
The recursion problem was particularly nice. The setup led to and, if
I recall, explicitly mentioned recursion. It also talks about a key
challenge - data mutability. The question states that after returning
from a &amp;#34;subgame&amp;#34; - the recursion - you have to continue the original
game from where it left off - state management. If you&amp;#39;re language
passes references in your calls this could lead to trouble. I&amp;#39;m
guessing (hoping?) that for people who solved that day who were new to
recursion got a deeper understanding than just through the usual n!
and such.&lt;/p&gt;
&lt;p&gt;
Another thing I liked was the spiraling. That, in teacher talk, is
when you go back to an earlier topic. This year had three questions
based on Cellular Autoamta. The first was the basic, the next took you
to a higher dimension and the third to a different shape. Each one
reviewed and extend fro the earlier problem. I loved it. This might
sound similar to last year&amp;#39;s intcode but the difference is that evne
if you didn&amp;#39;t complete the earlier problems you had a shot at the
latter ones. With Intcode if you had something wrong with your earlier
interpreter you were out of luck.&lt;/p&gt;
&lt;p&gt;
The allergens problem also allowed for the use of the same method you
used to solve the boarding pass problem. &lt;/p&gt;
&lt;p&gt;
Loved the spiraling.&lt;/p&gt;
&lt;p&gt;
I could probably go on but this post is already long enough.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-5&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-5&#34;&gt;
Links
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-5&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
I&amp;#39;ll finish off with links to my earlier posts on Advent of Code.&lt;/p&gt;
&lt;p&gt;
Already looking forward to next year.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-leadin.&#34;&gt;advent-2020-leadin.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-day-01&#34;&gt;advent-2020-day-0&lt;/a&gt;1&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-day02&#34;&gt;advent-2020-day02&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-day03&#34;&gt;advent-2020-day03&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-day04&#34;&gt;advent-2020-day04&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-day05&#34;&gt;advent-2020-day05&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-day06&#34;&gt;advent-2020-day06&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-day0708&#34;&gt;advent-2020-day0708&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-day0910&#34;&gt;advent-2020-day0910&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-day11&#34;&gt;advent-2020-day11&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-day14&#34;&gt;advent-2020-day14&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-day16&#34;&gt;advent-2020-day16&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-1718&#34;&gt;advent-2020-1718&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-19-23&#34;&gt;advent-2020-19-23&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-21-24&#34;&gt;advent-2020-21-24&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-final-thoughts&#34;&gt;advent-2020-final-thoughts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A Teacher Looks at Advent of Code 2020 - Days 21 and 24</title>
      <link>https://cestlaz.github.io/post/advent-2020-21-24/</link>
      <pubDate>Thu, 24 Dec 2020 11:43:14 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-21-24/</guid>
      <description>
&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2020/day/24&#34;&gt;Day 24&lt;/a&gt; didn&amp;#39;t take that much time so I had a chance to go back and
finish &lt;a href=&#34;https://adventofcode.com/2020/day/21&#34;&gt;day 21&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
As usual, all my code is up &lt;a href=&#34;https://github.com/zamansky/advent2020&#34;&gt;here&lt;/a&gt;. &lt;/p&gt;
&lt;div id=&#34;outline-container-headline-1&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-1&#34;&gt;
Day 21
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-1&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2020/day/21&#34;&gt;Problem Link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
It took me a while to get my head around this example. You have a set
of recipes. Each recipe has a list of ingredients and a list of
allergens. Your job for part 1 was basically to determine which
ingredients don&amp;#39;t contain any allergens. Part 2 had you determining
which ingredient had which allergen.&lt;/p&gt;
&lt;p&gt;
Part of what I think made this hard was that ingredients were just
random strings of letters as opposed to actual ingredients or at least
pronounceable words or letter strings.&lt;/p&gt;
&lt;p&gt;
The key part of the description as that each allergen was present in
&lt;strong&gt;exactly one&lt;/strong&gt; ingredient and each ingredient had &lt;strong&gt;at most&lt;/strong&gt; one
allergen. &lt;/p&gt;
&lt;p&gt;
So, for part 1, the tact was for each allergen, take all the recipes
that had it. In the example, the first and second recipes had
dairy (one indexing). Since only one ingredient can have the dairy
allergen the that ingredient must be in both lists.&lt;/p&gt;
&lt;p&gt;
If you take all the recipes that have the dairy allergen and take each
of their lists of ingredients as a set and find all their
intersections, you&amp;#39;ll be left with all the ingredients that can have
the dairy allergen.&lt;/p&gt;
&lt;p&gt;
Do this with all the allergens and you&amp;#39;ll have all the ingredients
that could contain them. The other igredients are safe and lead to the
answer to part 1.&lt;/p&gt;
&lt;p&gt;
Part 2 had you identifying each ingredient / allergen
pair. Fortunately, the data set we ended up with for part 1 - each
allergen and it&amp;#39;s list of possible ingredients was made to order. One
of them had only one ingredient per allergen. We could identify that
one and then remove that ingredient from the remaining allergen&amp;#39;s
lists. Then repeat to find the next one and then the next. This is
similar to the solution to day 16. Of course this isn&amp;#39;t a general
solution but fortunately the data was all set up for us.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-2&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-2&#34;&gt;
Day 24
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-2&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2020/day/24&#34;&gt;Problem Link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
Back to Cellular Automata!!!!!! The catch this time is the world is a
hex grid. This means that each cell has six neighbors so using a 2D
array or similar representation seems like an even worse idea than it
was for the 3D and 4D problems earlier this month.&lt;/p&gt;
&lt;p&gt;
Even before representing the world parsing was an issue. Since a given
cell can have neighbors to the east, west, northeast, northwest,
southeast or southwest, instructions are given with a line of &amp;#34;moves&amp;#34;
describing a tile to flip starting from 0,0. &lt;/p&gt;
&lt;p&gt;
For example, the line &amp;#34;EEE&amp;#34; would move three east from the origin and
flip that tile while &amp;#34;ESEE&amp;#34; would move one east, one southest and then
one further east and flipt the tile there.&lt;/p&gt;
&lt;p&gt;
Fortunately, this wasn&amp;#39;t too bad. As we traverse down the line, if we
see an &lt;strong&gt;e&lt;/strong&gt; or a &lt;strong&gt;w&lt;/strong&gt; then the instruction is one character so we add
the instruction to a list of steps an then continue. Otherwise the
instruction is 2 characters so we take 2 and add the instruction adn
then proceed.&lt;/p&gt;
&lt;p&gt;
Next was the data representation. It seemed that a list of live cells
would again be the best solution. I figured on using this mapping: &lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;E&lt;/td&gt;
&lt;td&gt;(-2,0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;W&lt;/td&gt;
&lt;td&gt;(2,0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NE&lt;/td&gt;
&lt;td&gt;(-1,-1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NW&lt;/td&gt;
&lt;td&gt;(1,-1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SE&lt;/td&gt;
&lt;td&gt;(-1,1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SW&lt;/td&gt;
&lt;td&gt;(1,1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
I later found out that this is called &amp;#34;double coordinates.&amp;#34; Since
we&amp;#39;re not storing the full hex grid there&amp;#39;s no waste anyway and I
wasn&amp;#39;t planning on making a visualization so I didn&amp;#39;t worry about how
this would map to an actual screen.&lt;/p&gt;
&lt;p&gt;
Now, finding the coordinate of a tile was pretty easy. In Clojure
it&amp;#39;s: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;;; assume deltas is a lookup dictionary of the above mapping&lt;/span&gt;

  (&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;get-tile-location [steps]
    (reduce (&lt;span style=&#34;color:#66d9ef&#34;&gt;fn &lt;/span&gt;[loc step]
              (map + loc (&lt;span style=&#34;color:#a6e22e&#34;&gt;deltas&lt;/span&gt;  step))
              ) [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] steps))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
In Python it would look more like this: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# assume deltas is a dictionary with the above mapping&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;# and steps is a list of instructions [&amp;#34;e&amp;#34;,&amp;#34;w&amp;#34;,&amp;#34;se&amp;#34;, etc]&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; step &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; steps:
      loc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [sum(x) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; zip(loc, deltas[step])]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
We can now convert any input line of instructions to a coordinate. If
we write a routine to flip a tile we can now set up our world and
answer part 1.&lt;/p&gt;
&lt;p&gt;
Part 2 involved basically turning the part 1 world into a cellular
automaton. Fortunately, this was easy given the solution to earlier CA
problems. It as just a matter of updating the get-neighbors routine
and the rule to go from one generation to the next and we&amp;#39;re done.&lt;/p&gt;
&lt;p&gt;
I enjoyed this - it was a nice twist on the earlier CA
questions. First we had a simple CA, then higher dimensions and now
changing the layout of the world but still within 2 dimensions. Once
we had a way of representing a tile and mapping from a tile to its
neighbors we had already solved the problem.&lt;/p&gt;
&lt;p&gt;
One more day to go but it&amp;#39;s been a nice run of problems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A Teacher Looks at Advent of Code 2020 - 19 through 23</title>
      <link>https://cestlaz.github.io/post/advent-2020-19-23/</link>
      <pubDate>Wed, 23 Dec 2020 15:09:38 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-19-23/</guid>
      <description>
&lt;p&gt;
A few days have past so it&amp;#39;s time for an update. Two more days to go
and while I haven&amp;#39;t completed all the problems, I have accumulated 43
stars which is a personal best. Given the nature of the problems I&amp;#39;m
missing, I might even go back and do them at some point. Of course, I
may very well also just crash out on the final two days.&lt;/p&gt;
&lt;p&gt;
As usual, all my code is up &lt;a href=&#34;https://github.com/zamansky/advent2020&#34;&gt;here&lt;/a&gt;. &lt;/p&gt;
&lt;div id=&#34;outline-container-headline-1&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-1&#34;&gt;
Day 19
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-1&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2020/day/19&#34;&gt;Problem Link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
Not a whole lot to say about this one. It&amp;#39;s the weekend and AoC has
traditionally had longer / harder problems over the weekends. I was
surprised when the first weekend&amp;#39;s problems - 12 and 13 weren&amp;#39;t
significantly longer than the surrounding days. &lt;/p&gt;
&lt;p&gt;
I read over this and it screamed &lt;strong&gt;parser&lt;/strong&gt; and to be honest, I really
wasn&amp;#39;t up for writing a parser on a Saturday morning. Instead, I
cheaped out.  I looked for a Clojure parser generator and found
&lt;a href=&#34;https://github.com/engelberg/instaparse&#34;&gt;instaparse&lt;/a&gt;. What&amp;#39;s more, instaparse supported input in the form of the
provided AoC data so I literally just had to read the grammar into
instaparse and run it on the data for the answer. Part 2 was pretty
much the same.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-2&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-2&#34;&gt;
Day 20
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-2&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2020/day/20&#34;&gt;Problem Link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
This was the big one. Basically taking 144 tiles and figuring out how
to form them in an image. &lt;/p&gt;
&lt;p&gt;
I finished part 1. I read in all the tiles and then for each, compared
it&amp;#39;s edges with the edges of the other tiles (and the reverse of the
edges to account for transformations). This told me how many other
tiles each tile connects with. Central tiles each connect to 4 other
ties, edges, to three but corners only to 2. Part 1 just had you find
the corners so it wasn&amp;#39;t too big a deal.&lt;/p&gt;
&lt;p&gt;
Part 2 involves assembling the image and then finding sea monsters. I
haven&amp;#39;t done this yet. Armed with the corner, it should be easy to
find the top row and then build the image going down. &lt;/p&gt;
&lt;p&gt;
I think it&amp;#39;s going to be a bear to code though since each tile has to
be transformed via flipping and/or rotating into the correct
orientation.&lt;/p&gt;
&lt;p&gt;
I&amp;#39;m hoping to get back to it. We&amp;#39;ll see though. &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-3&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-3&#34;&gt;
Day 21
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-3&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2020/day/21&#34;&gt;Problem Link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
Haven&amp;#39;t done this one yet. Just couldn&amp;#39;t get my head around the
example on an early Monday morning. &lt;/p&gt;
&lt;p&gt;
I don&amp;#39;t know if I&amp;#39;ll finish question 20 but I do really hope to get
back to give this one a go.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-4&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-4&#34;&gt;
Day 22
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-4&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2020/day/22&#34;&gt;Problem Link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
Part 1 here was pretty straightforward - you had a few rules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if player 1&amp;#39;s deck is empty, player 2 wins&lt;/li&gt;
&lt;li&gt;if player 2&amp;#39;s deck is empty, player 1 wins&lt;/li&gt;
&lt;li&gt;otherwise both players draw a card and whoever drew the higher card gets both, they go on the
back of the winners deck and you continue play.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That&amp;#39;s it. Basically just run the simulation.&lt;/p&gt;
&lt;p&gt;
Part 2 added a recursive subgame. Under certain circumstances you
pause the current game and do a little subgame. The catch is that you
have to save the state of the current game and when the subgame or
subgames end, you continue the suspended game from where you left off.&lt;/p&gt;
&lt;p&gt;
This means that if you are representing your decks with arrays or some
other data structure where you can change the elements you have to be
careful. In Clojure, however, where data is immutable by default you
don&amp;#39;t have to worry about that. &lt;/p&gt;
&lt;p&gt;
I was basically able to just rewrite my play routine for the new
rules and whenever we had to go to a subgame, I just made a
traditional recursive call. My guess is that if I had coded this up
originally in Java or C++ I probably would have had a harder time
going from part 1 to part 2. On the other hand, there were some
problems with Java or C++ would have made my part 1 to part 2
transitions easier - depends on the problem. &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-5&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-5&#34;&gt;
Day 23
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-5&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2020/day/23&#34;&gt;Problem Link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
This was the fun one - at least from a teacher&amp;#39;s point of view. &lt;/p&gt;
&lt;p&gt;
Like day 22 you had to implement a game. You set up a bunch of
numbered cups in a circle and then: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;remove the three cups right after the current cup&lt;/li&gt;
&lt;li&gt;find out where they should be reinserted based on the game rules
(see the problem link for details)&lt;/li&gt;
&lt;li&gt;reinsert those three cups at that reinsertion point.&lt;/li&gt;
&lt;li&gt;move from the current cup to the next cup.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I did part 1 using a simple list and list manipulations. I used
Clojure but the python equivalent would be to have a list representing
all the cups, move around ti with mod, and remove cups and add them
using slices.&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# given board = [3,8,9,1,2,5,4,6,7&lt;/span&gt;

  &lt;span style=&#34;color:#75715e&#34;&gt;# to get the next board state&lt;/span&gt;
  current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; board[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
  to_remove &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; board[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]
  remaining &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; board[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;:]
  idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; find_target(board,remove)
  newboard &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; remaining[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:idx] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; to_remove &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; remaining[idx:] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; [current]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
I might have the indexing a little off and the &lt;code&gt;find_target&lt;/code&gt; routine
isn&amp;#39;t shown adn might have different parameters. As I&amp;#39;ve said, I wrote
my solution in Clojure. This should give the general idea though. &lt;/p&gt;
&lt;p&gt;
You basically had to run through 10 turns to find the answer.&lt;/p&gt;
&lt;p&gt;
Part 2 added a twist - the game board was now &lt;strong&gt;one million&lt;/strong&gt; in size
and you had to run the simulation through &lt;strong&gt;ten million&lt;/strong&gt; turns. No way
was my part 1 solution going to work. &lt;/p&gt;
&lt;p&gt;
The problem called for something that required fewer list traversals
and builds and where it would be quick and easy to find a given
element. &lt;/p&gt;
&lt;p&gt;
My first thought was to build a traditional linked list. That would
help but it would also require a number of linear traversals.&lt;/p&gt;
&lt;p&gt;
Next thought? How about a dictionary? &lt;/p&gt;
&lt;p&gt;
If you set up a dictionary where the keys are the nodes and the values
represent the pointer to the next node you could really quickly and
easily both traverse and manipulate the data set. &lt;/p&gt;
&lt;p&gt;
For example, if your board was [3,8,9,1] then you&amp;#39;d use this
dictionary to represent it - remember the 1 wraps back around to
the 3.
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;  nodes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; : &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;,
           &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; : &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;,
           &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt; : &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
           &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; : &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
So if you&amp;#39;re current node was represented in a variable &lt;code&gt;current&lt;/code&gt; the
three nodes you&amp;#39;ll remove would be &lt;code&gt;[nodes[current],
noeds[nodes[current]], nodes[nodes[nodes[current]]] ]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;
As an added bonus, the question pointed out that your data set would
have every positive integer represented once. That is, part 1 had a 9
item list with all the values 1 through 9 and the million item one had
values 1 through 1 million. This makes finding the insertion point
both easy and fast.&lt;/p&gt;
&lt;p&gt;
It turns out that I think the dictionary based solution is actually
cleaner than the list one in addition to being faster.&lt;/p&gt;
&lt;p&gt;
This solution was no speed demon - still took ~40 seconds to get an
answer but that&amp;#39;s good enough for me. &lt;/p&gt;
&lt;p&gt;
Of the problems I wrote up today, this one was my favorite. Students
typically think of data structures as what they are - if they have an
array, use it as an array, a linked list is a linked list and a
dictionary or hash table is, well, you know. If you need a linked
list, you need to make a traditional linked list - not so. this is a
great example of using a dictionary as a hash table. There are
conceptual data structures and actual in computer
representations. Often you use the implementation directly - use a
hash table to store data for lookup or use an array to represent a
list. It can be very empowering though when the student sees that
the implementations are just tools in the belt and they can be used in
all sorts of interesting ways.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A Teacher Looks at Advent of Code 2020 - Days 17 and 18</title>
      <link>https://cestlaz.github.io/post/advent-2020-1718/</link>
      <pubDate>Fri, 18 Dec 2020 12:35:57 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-1718/</guid>
      <description>
&lt;div id=&#34;outline-container-headline-1&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-1&#34;&gt;
Day 17
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-1&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2020/day/17&#34;&gt;Day 17&lt;/a&gt; brought back Cellular Automata. It was a nice follow up to &lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-day11/&#34;&gt;day
11&lt;/a&gt;. In my &lt;a href=&#34;https://cestlaz.github.io/post/advent-2020-day11/&#34;&gt;writeup&lt;/a&gt; I talked about data representation - how a Cellular
Automoton like Conway&amp;#39;s game of life is a nice 2D array project in a
class like APCS-A but multi dimensional arrays are only one way to
represent a cellular automaton. Day 17 really drove that home. &lt;/p&gt;
&lt;p&gt;
The actual rules were pretty simple - if a cell is active and has 2 or
3 active neighbors it stays active. If it&amp;#39;s inactive and has three
active it becomes active. Otherwise the cell is inactive. &lt;/p&gt;
&lt;p&gt;
The catch for part 1 is that this CS is in three dimensions. Each and
a cell&amp;#39;s neighbors are defined as all coordinates that differ by one
in any of the three dimensions. So, if a cell is at an (x,y,z) location
it&amp;#39;s neighbors will be at (x+1,y,z), (x-1,y,z), (x+1,y+1,z),
(x+1,y-1,z), etc. for 26 neighbors in all. &lt;/p&gt;
&lt;p&gt;
You could use a list  within a list within a list or a three
dimensional array to represent your world but that&amp;#39;s tricky and error
prone. What&amp;#39;s worse, part 2 took the CA into the fourth dimension.&lt;/p&gt;
&lt;p&gt;
Better is to just keep a list or set of active cells. Then the problem
becomes pretty easy. You need to be able to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Find all of a cell&amp;#39;s neighbors - this is pretty easy because you
can iterate over all the +1 and -1 possibilities for each of the x,
y, and z values.&lt;/li&gt;
&lt;li&gt;Find all the potential cells for the next state - this is also
pretty easy because it&amp;#39;s the set of all cells that are currently
active along with all of their neighbors. &lt;/li&gt;
&lt;li&gt;Count a given cell&amp;#39;s active neighbors - this is easy once you&amp;#39;ve
done the find neighbors routine. &lt;/li&gt;
&lt;li&gt;A way to test if a cell is active which is just checking to see if
it&amp;#39;s in your active cells list or set.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Then, it&amp;#39;s pretty easy to run the CA: 
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# pythonesque pseudocode &lt;/span&gt;
potential_cells &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; find_all_neighbors(current_active_cells)
new_cells &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; cell &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; potential_cells: 
  n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count_neighbors(cell)
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; is_active(cell) &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; (n&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;):
    new_cells&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(cell)
  &lt;span style=&#34;color:#66d9ef&#34;&gt;elif&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; is_active(cell)) &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;:
    new_cells&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(cell)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Then you just have to run generate new states until you get the
answer.&lt;/p&gt;
&lt;p&gt;
Part 2 extended the CA to 4 dimensions. If you had a multidimensional
array this would get super message but with a list of active cells,
the changes are minimal - just add an extra coordinate, update getting
the neighbors and you&amp;#39;re good to go.&lt;/p&gt;
&lt;p&gt;
This is a case of where thinking through your data representation can
be a big win.&lt;/p&gt;
&lt;p&gt;
Clojure code &lt;a href=&#34;https://github.com/zamansky/advent2020/blob/main/src/day17.clj&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-2&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-2&#34;&gt;
Day 18
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-2&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2020/day/18&#34;&gt;Day 18&lt;/a&gt; was all about evaluating math expressions. For part 1 you had
parenthesized expressions consisting of numbers * and + that you had
to evaluate but you had to do it by first doing parens then left to
right - multiplication was not a higher precedence.&lt;/p&gt;
&lt;p&gt;
This sounds like a parsing first problem but it turns out I was able
to exploit some of Clojure&amp;#39;s language features. Looking at the
subreddit after solving it seems that a bunch of other languages also
have features that could be exploited.&lt;/p&gt;
&lt;p&gt;
Clojure represents data (and programs) as &lt;a href=&#34;https://en.wikipedia.org/wiki/S-expression&#34;&gt;S-Expressions&lt;/a&gt; - basically
stuff in parens. As a prefix language, instead of writing 10+20, in
Clojure you&amp;#39;d write &lt;code&gt;(+ 10 20)&lt;/code&gt;, that is  run the plus function on 10
and 20. If you have something lie &lt;code&gt;(+ 10 (* 20 3))&lt;/code&gt;, Clojure has to
evaluate the inner S-Expression (sexp) before it can add that to +10
so Clojure can do the parsing for us. We can take an input string and
convert it to an sexp using &lt;code&gt;read-string&lt;/code&gt;  but if we just try to do
&lt;code&gt;(read-string &amp;#34;1 + 2 + 3&amp;#34;)&lt;/code&gt; we&amp;#39;d get an error because &amp;#34;1 + 2 + 3&amp;#34;
isn&amp;#39;t a valid sexp so we just surround it by parens:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;def &lt;/span&gt;equation-sexp (&lt;span style=&#34;color:#a6e22e&#34;&gt;read-string&lt;/span&gt; (str &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1 + 2 * 3 + (4 * 5 )&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
The above would leave us with the sexp (1 + 2 * 3 + (4 * 5 )).&lt;/p&gt;
&lt;p&gt;
Next, forgetting the inner parens, we can write a function that will
evaluate an sexp of the form (1 + 2 * 3 + …) etc. Basically, this can
be done with a reduce. Start with the first value then take the rest
of the list two at a time, the first of each pair is an operator and
the second is an operand so apply the operand to the other number in
the pair and your overall result so far.&lt;/p&gt;
&lt;p&gt;
In Clojure it looks like this: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;part1-eval [f &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; r]
  (reduce (&lt;span style=&#34;color:#66d9ef&#34;&gt;fn &lt;/span&gt;[ans [op next]]
            (apply op [ans next] )) f (&lt;span style=&#34;color:#a6e22e&#34;&gt;partition&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; r)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Next, we insert that function name to the start of each sexp so 
(1 + 2 * 3 + (4 * 5*)) becomes (part1-eval 1 + 2 * 3 + (part1-eval 4 *
5)). Finally we can do a  Clojure &lt;strong&gt;eval&lt;/strong&gt; on this form which will run
part1-eval on the rest of the sexp which will first run part1-eval on
the 4 * 5, that will return the 20 and then the first part1-eval will
finish it&amp;#39;s calculations to give you the answer. &lt;/p&gt;
&lt;p&gt;
Part 2 was similar but there you had to perform addition before
multiplication. All that was necessary was write a part2-eval function
that would stand in for the part1-eval.&lt;/p&gt;
&lt;p&gt;
The idea is to take an sexp like (1 + 2 * 3 + 4 * 5) we first split this
list around the * this gives us (1 + 2) (&lt;strong&gt;) (3 + 4) (&lt;/strong&gt;) (5). We then
filter this to remove the non numbers which gives (1 2) () (3 4) (5)
(). Then we remove the empty lists: (1 2) (3 4) (5). Add the elements
of each list: 3 7 5 and then multiply them together.&lt;/p&gt;
&lt;p&gt;
All the code is &lt;a href=&#34;https://github.com/zamansky/advent2020/blob/main/src/day18.clj&#34;&gt;here&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;
I like day 17 a lot or some variant for students to discuss data
representations but I think 18 is a little more advanced and probably
wouldn&amp;#39;t touch it in an early CS class - it was fun to work through
though :-). &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A Teacher Looks at Advent of Code 2020 - day 16</title>
      <link>https://cestlaz.github.io/post/advent-2020-day16/</link>
      <pubDate>Wed, 16 Dec 2020 17:12:56 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day16/</guid>
      <description>
&lt;p&gt;
Today&amp;#39;s problem was a fun one to solve. Why was it fun? Stay tuned,&lt;/p&gt;
&lt;p&gt;
The basic gist is that you have a plane ticket which is a set of
numbers but you don&amp;#39;t know which number maps to which category - row,
seat, gate, etc. You also know the number ranges for each
category. For example, row might be a number between 6 and 11 or 33
through 44 while a seat might be 13 through 40 or 45 through 50. &lt;/p&gt;
&lt;p&gt;
Finally, you also can see a number of nearby tickets - each also as
tring of numbers. &lt;/p&gt;
&lt;p&gt;
For part 1 you had to determine how many of the nearby tickets are
valid. A ticket is valid if all the numbers on it fall into at least
one category range. &lt;/p&gt;
&lt;p&gt;
See the &lt;a href=&#34;https://adventofcode.com/2020/day/16&#34;&gt;full description&lt;/a&gt; for all the details. &lt;/p&gt;
&lt;p&gt;
First up - parsing - a little cumbersome but not too bad.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Split the input into the three main sections - categories, your
ticket, nearby tickets&lt;/li&gt;
&lt;li&gt;Convert the categories into a usable form&lt;/li&gt;
&lt;li&gt;Convert your ticket into a list of numbers&lt;/li&gt;
&lt;li&gt;Convert the nearby tickets into a list of tickets each one being a
list of numbers.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Taking each step in turn and it&amp;#39;s not too bad - particularly if you&amp;#39;re
comfortable with regular expressions.&lt;/p&gt;
&lt;div id=&#34;outline-container-headline-1&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-1&#34;&gt;
part 1
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-1&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
Representing the categories leads us to our first interesting
decision. How will we test to see if a ticket is valid and based on
that how will we represent the categories?&lt;/p&gt;
&lt;p&gt;
Each category has two ranges connected with an &lt;strong&gt;or&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
row: 6-11 or 33-44
seat: 13-40 or 45-50
&lt;/pre&gt;
&lt;p&gt;
One could make a construct to hold the bounds, loop through the nearby
tickets and for each value, run an if statement with the two ranges
connected by an &lt;strong&gt;or&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;
This is where a class can talk about code vs data - a topic I&amp;#39;m really
fond of.&lt;/p&gt;
&lt;p&gt;
Instead of taking the above range and having some test like: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; ticket:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (number &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; low1 &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; high1) &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; \
     (number &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; low2 &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; high2):
       do something&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
or specifically for the row example:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; ticket:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (number &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; \
     (number &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;33&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;44&lt;/span&gt;):
       do something&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
you could make a set with all the possible seats  and then just test
to see if the seat was in the set: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;r1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set( range(low1,high&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;))
r2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set( range(low2,hight2&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;))
valid_seats &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r1&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;union(r2)

&lt;span style=&#34;color:#75715e&#34;&gt;# then later&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; seat &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; valid_seats:
  do something&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
I just find this more elegant. &lt;/p&gt;
&lt;p&gt;
For part 1 I just made a big set with all the valid seats and then
checked each ticket to see if each if its numbers were in the valid
seats. &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-2&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-2&#34;&gt;
part 2
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-2&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
For part 2 first you had to remove all the invalid tickets from the
nearby tickets. Since you figured out how to identify a valid ticket
in part one this shouldn&amp;#39;t be too ahrd.&lt;/p&gt;
&lt;p&gt;
Then we have to sleuth out which column from the tickets represented
which category. This would make a great group activity in a class,
particularly with an interactive language. This is a great data
exploration and representation problem.&lt;/p&gt;
&lt;p&gt;
To get more data, I thought I&amp;#39;d write a routine to pull all of one
column from the nearby tickets. Then I could see if all the values in
that row were valid for a particular category. For example, are all
the first numbers of all the tickets valid numbers for row. If so,
that column could represent row. Of course it could also represent
something else as well.&lt;/p&gt;
&lt;p&gt;
Now that i could test to see if a column is valid for a category I
decided to build some data. I built a list of all the possible
categories for each row.&lt;/p&gt;
&lt;p&gt;
Part of it looked sort of like this (but in clojure):&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;[ [&lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt;, [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wagon&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;arrival-station&amp;#34;&lt;/span&gt;] ],
  [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;, [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wagon&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;arrival-station&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;route&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;train&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;row&amp;#34;&lt;/span&gt;]]
&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Examining this table, I noticed that one row had only one category,
another had only 2 then one three etc. Great - we can now solve this
by plugging in the row we know, then the next one, then the next etc.&lt;/p&gt;
&lt;p&gt;
The explorations led to an easy answer. I sorted the list and looped
through. At each iteration I: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Added the current category and its associated row to the solution
set.&lt;/li&gt;
&lt;li&gt;Removed that category from the rest of the lines&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;When done we had a dictionary with a mapping from category to
row. From there it was pretty simple to find the part 2 answer.&lt;/p&gt;
&lt;p&gt;
Lots of good stuff here. I love the data explorations and the way it
can lead to a pretty straightforward solution.&lt;/p&gt;
&lt;p&gt;
Full solution in clojure can be found here: &lt;a href=&#34;https://adventofcode.com/2020/day/16&#34;&gt;https://adventofcode.com/2020/day/16&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
So far I&amp;#39;ve managed to complete each day - 32 stars. That beats my 31
from last year adn my top year of 40 back in 2016. Tomorrow I give my
last exams and grading ca really begin so we&amp;#39;ll see if I can keep
going but so it&amp;#39;s been a fun Advent of Code year so far.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A teacher looks at Advent of Code day 14</title>
      <link>https://cestlaz.github.io/post/advent-2020-day14/</link>
      <pubDate>Mon, 14 Dec 2020 14:30:47 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day14/</guid>
      <description>&lt;p&gt;
Time for &lt;a href=&#34;https://adventofcode.com/2020/day/14&#34;&gt;Day 14&lt;/a&gt;!!!&lt;/p&gt;
&lt;p&gt;
I didn&amp;#39;t write up day 12 but here&amp;#39;s a Clojure &lt;a href=&#34;https://www.youtube.com/watch?v=k8fvaAZRtts&amp;amp;feature=youtu.be&#34;&gt;video&lt;/a&gt; runthrough. I also
didn&amp;#39;t write up day 13 mostly because I hacked together my part 2 in
Python and still want to rewrite it in decent clojure. In any event,
all my solutions are up on &lt;a href=&#34;https://github.com/zamansky/advent2020&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
Day 14 had a few interesting things going on. At its core it&amp;#39;s a small
machine simulator where you have to deal with binary numbers. One of
the rubs is that the numbers are 36 digits which could be a problem if
your language / machine uses 32 bits to represent integers. &lt;/p&gt;
&lt;p&gt;
Right off, assuming you have large enough ints you have an interesting
choice. Do you work with the data them as numbers or do you just do
string manipulations. &lt;/p&gt;
&lt;p&gt;
I decided to do part 1 as numbers which leads to a nice little
exercise of using bitwise logic operations to turn bits on or off. &lt;/p&gt;
&lt;p&gt;
Part 2 was better solved, at least for me using string
manipulations. That part had a nice little recursive subproblem -
mapping wildcard values in the &amp;#34;mask&amp;#34; to all the possible combinations
of zeros and ones.&lt;/p&gt;
&lt;p&gt;
Both problems also had a bit of fun parsing and, at least for me, a
few neat clojure constructs. &lt;/p&gt;
&lt;p&gt;
I think you could turn this problem into a fun set of class
exercises. My code can be found &lt;a href=&#34;https://github.com/zamansky/advent2020/blob/main/src/day14.clj &#34;&gt;here&lt;/a&gt; and even if you don&amp;#39;t do Clojure,
you might want to check out the video runthrough:&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/oVVHU7PDHyw&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>A teacher looks at Advent of Code 2020 - Day 11</title>
      <link>https://cestlaz.github.io/post/advent-2020-day11/</link>
      <pubDate>Fri, 11 Dec 2020 15:00:43 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day11/</guid>
      <description>&lt;p&gt;
Today was &lt;a href=&#34;https://en.wikipedia.org/wiki/Cellular_automaton&#34;&gt;Cellular Automaton&lt;/a&gt; Day at Advent of Code. You have a world
that&amp;#39;s usually represented as a grid of cells. Each cell can be in a
certain state. Given a certain state, the next state is determined by
simple rules like for a given cell how many of it&amp;#39;s neighbors are the
same color. &lt;/p&gt;
&lt;p&gt;
The most popular Cellular Automat is probably &lt;a href=&#34;https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life&#34;&gt;Conway&amp;#39;s Game of Life&lt;/a&gt;
where each cell can be either alive or dead in a given generation and
in the next generation the state will be determined by how many of its
neighbors are currently dead or alive. &lt;/p&gt;
&lt;p&gt;
I&amp;#39;ve always liked teaching with Celluar Automata and explored it
deeply in the intro course I designed at Stuy. NetLogo is perfect for
representing a CA (&lt;a href=&#34;https://cestlaz.github.io/posts/2016-01-15-shift-image/&#34;&gt;old post&lt;/a&gt;) and we even do things like using a CS to
&lt;a href=&#34;https://cestlaz.github.io/posts/2016-01-17-maze-ca/&#34;&gt;solve a maze&lt;/a&gt;. Good stuff.&lt;/p&gt;
&lt;p&gt;
Today&amp;#39;s problem set up a CA where each cell can be one of three
states - floor, occupied chair, unoccupied chair. The floor never
changed but the chairs can change from occupied to unoccupied and back
based on neighbors. I actually really like teh question. It&amp;#39;s posed as
passengers prefer to sit in s eats next to other empty seats which is
true and the overall problem is much more realistic and therefor
accessible than Conway&amp;#39;s game of life. I think I might lead with it if
I do CA again with my students. &lt;/p&gt;
&lt;p&gt;
You can find my Clojure solutions &lt;a href=&#34;https://github.com/zamansky/advent2020/blob/main/src/day11.clj&#34;&gt;here&lt;/a&gt;. They were pretty
straightforward. I spend too much time going down the &amp;#34;learn how to
write a lazy sequence in Clojure&amp;#34; rabbit hole for part 2 before just
writing it in a more traditional way.&lt;/p&gt;
&lt;p&gt;
To me there are a couple of interesting things at play when teaching
CA. The first is state management and synchronization. When beginners
work on a CA they frequently look at a cell, figure out it&amp;#39;s next
generation value and then replace the cell with its new value. Then,
later they look at a neighboring cell and when that cell looks at its
neighbors it gets the changed value not the original one. Clearly a
problem. &lt;/p&gt;
&lt;p&gt;
Writing a CA makes it clear that you have to keep your state clean
while you build a new state for the next generation. That&amp;#39;s an
important lesson to learn.&lt;/p&gt;
&lt;p&gt;
The other interesting teaching point is with data representation. CA
is frequently taught as a 2D array exercise. This makes sense -
simulations like Conway&amp;#39;s Game of Life work perfectly in a 2D array
and if you&amp;#39;re doing graphics with your class you can also get cool
animations through the generations. &lt;/p&gt;
&lt;p&gt;
That said, there are other valid representations that could be
superior at times. You might have a list of living cells or a hash
tabe of cells if you have more than 2 living states. This can be far
superior from a space efficiency point of view if you don&amp;#39;t have a lot
of living cells compared with your world size - say you have a CA with
a theoretically unlimited size. &lt;/p&gt;
&lt;p&gt;
So, there it is - thoughts on today&amp;#39;s problem. As I said, it was
pretty straightforward but I also really like the setup and will
probably use it in class at some point in the future.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Teacher looks at Advent of Code 2020 - days 9 and 10</title>
      <link>https://cestlaz.github.io/post/advent-2020-day0910/</link>
      <pubDate>Thu, 10 Dec 2020 16:52:45 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day0910/</guid>
      <description>&lt;p&gt;
As we get closer to the end of the semester and time becomes scarcer
I&amp;#39;m wondering how many more I&amp;#39;ll finish. Barely had time to do days 9
and 10.&lt;/p&gt;
&lt;p&gt;
Not much to say about &lt;a href=&#34;https://adventofcode.com/2020/day/9&#34;&gt;day 9&lt;/a&gt; Part one was basically a rehash of day 1
part 1 but with a sliding widow. Part 2? I just brute force tried all
the subranges. I meant to go back to try to improve the solution but
didn&amp;#39;t have a chance. &lt;/p&gt;
&lt;p&gt;
Clojure code can be found &lt;a href=&#34;https://github.com/zamansky/advent2020/blob/main/src/day09.clj&#34;&gt;here&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2020/day/10&#34;&gt;Day 10&lt;/a&gt; was more interesting. &lt;/p&gt;
&lt;p&gt;
I misread part 1 but ultimately, my solution was to: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;read in the data&lt;/li&gt;
&lt;li&gt;sort it&lt;/li&gt;
&lt;li&gt;prepend a 0&lt;/li&gt;
&lt;li&gt;append an additional value of the max + 3 to the end&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Then loop through comparing adjacent values and keep track of the
differences which can be 1, 2, or 3. &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;data&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[ int(x) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;../data/sample10-1.dat&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;readlines()]
data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sort()
data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;insert(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(max(data)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)

j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(data)&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
    diff&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;data[i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;data[i]
    j[diff&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;j[diff&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;

print(j)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Part 2 was where the fun starts - how many combinations of adapters
will take you from the start to the end.&lt;/p&gt;
&lt;p&gt;
For example, if we had adapters with voltages 1,4,5,6 given the
problem constraints that you can only connect an adapter to another
with a &amp;#34;joltage&amp;#34; of up to three less, you can only use the 1 voltage 1
way (coming from the source of 0).&lt;/p&gt;
&lt;p&gt;
4 can connect to only 1 so it can only be used 1 way.&lt;/p&gt;
&lt;p&gt;
5 can connect to 4 so it too can only be used 1 way.&lt;/p&gt;
&lt;p&gt;
6 is a change, it can connect to 5 or 4 so you could chain either
6–&amp;gt;5–&amp;gt;4–&amp;gt;1 or 6–&amp;gt;4–&amp;gt;1 so you can get to 6 two ways. &lt;/p&gt;
&lt;p&gt;
If a student knows recursion and recursive search it&amp;#39;s easy enough to
code something that tries all the paths but it&amp;#39;s going to get very
slow very fast.&lt;/p&gt;
&lt;p&gt;
With a couple of insights though this can lead to a nice dynamic
programming type solution. &lt;/p&gt;
&lt;p&gt;
First thing to notice is that, similar to day 7, instead of looking at
how many adapters a lower joltage adapter can lead to we can look at how
many lower joltage adapters a given adapter could have come from. &lt;/p&gt;
&lt;p&gt;
To do this, we can look at the adapters as a graph. We can build a
dictionary where the keys are the adapter joltages and the entries are
the lower joltage adapters it can connect with:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;build_reverse_map&lt;/span&gt;(data):
    graph&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{}
    data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; data[::&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(data)):
        current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; data[i]
        j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (j&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;len(data) &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; data[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; data[j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;):
            j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        graph[current]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;data[i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:j]
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; graph

rmap &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; build_reverse_map(data)&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt; &lt;/p&gt;
&lt;p&gt;
Line 3 reverses the list then for each item in the list, lines 6
through 8 find the adapters it can connect with. &lt;/p&gt;
&lt;p&gt;
The next insight is that instead of calculating all the possibilities
we can build them a step at a time. &lt;/p&gt;
&lt;p&gt;
Consider the first voltage from our above example of 1,4,5,6.&lt;/p&gt;
&lt;p&gt;
1 – it can only go to 0 so 0 is its only &amp;#34;neighbor&amp;#34; in the graph. We
can only get there 1 way so we can store 1 in ways[1].&lt;/p&gt;
&lt;p&gt;
4 – same deal - its only neighbor is 1. You can only get to 1 one way
so you can only get to 4 1 way - store it in ways[4]&lt;/p&gt;
&lt;p&gt;
5 – same deal, ways[5] = 1.&lt;/p&gt;
&lt;p&gt;
6 - now six is different. It has 2 neighbors - 5 and 4. You can get to
5 one way and 4 one way so we can get to 6 two ways (the sum of the
ways to get to each of it&amp;#39;s neighbors). Store that in ways[6]&lt;/p&gt;
&lt;p&gt;
Go through all the nodes and then ways[the last node] will have your
answer:  &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;ways&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{}
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; d &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
    ways[d]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; d &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:]:
    neighbors &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rmap[d]
    sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; neighbors:
        sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; ways[n]
    ways[d]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sum&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt; &lt;/p&gt;
&lt;p&gt;
Relatively straightforward and lightning fast. Dynamic programming
can be really hard to teach but I think this problem might be a good
one to do with an advanced data structures class. &lt;/p&gt;
&lt;p&gt;
For comparison, you can find the clojure code &lt;a href=&#34;https://github.com/zamansky/advent2020/blob/main/src/day10.clj&#34;&gt;here&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;
Fun problem today. Looking forward to tomorrow.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Teacher looks at Advent of Code 2020 - Days 7 and 8</title>
      <link>https://cestlaz.github.io/post/advent-2020-day0708/</link>
      <pubDate>Tue, 08 Dec 2020 14:47:17 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day0708/</guid>
      <description>&lt;p&gt;
Today we&amp;#39;ll talk about days &lt;a href=&#34;https://adventofcode.com/2020/day/7&#34;&gt;seven&lt;/a&gt; and &lt;a href=&#34;https://adventofcode.com/2020/day/8&#34;&gt;eight&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;
Let&amp;#39;s start with 7. I teach all morning on Mondays. I woke up and
worked out and then took a look at the problem in the few minutes
before class. It was certainly harder than days one through six but I
felt it was something I knew I could do based on past experience so I
quickly started to throw something together. I tried to finish it in
the between classes but couldn&amp;#39;t get the right answer to part
one. After class I spent more time debugging. I was pretty certain my
algorithm was right and it turns out it was. The problem was in my
parsing.&lt;/p&gt;
&lt;p&gt;
Anyway, to the problem. Read it over if you haven&amp;#39;t yet.&lt;/p&gt;
&lt;p&gt;
If you&amp;#39;ve studied data structures and algorithms you&amp;#39;ll recognize that
this problem can be viewed as a graph problem. Bags are nodes in the
graph and edges tell you what bags each bag can contain.&lt;/p&gt;
&lt;p&gt;
The data is set up to represent a graph like this: &lt;/p&gt;
&lt;img width=&#34;50%&#34; src=&#34;https://cestlaz.github.io/img/advent2020-0708/g1.png&#34;&gt;
&lt;p&gt;
I left out the weights (numbers of bags). This can be represented in
an adjacency list. The video does this in Clojure but in Python, you&amp;#39;d
get something that starts like this:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;lightred&amp;#39;&lt;/span&gt;     : [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;brightwhite&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;mutedyellow&amp;#39;&lt;/span&gt;],
 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;darkorange&amp;#39;&lt;/span&gt;   : [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;brightwhite&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;mutedyellow&amp;#39;&lt;/span&gt;],
 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;brightwhite&amp;#39;&lt;/span&gt;  : [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;shinygold&amp;#39;&lt;/span&gt;],
 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;mutedyellow&amp;#39;&lt;/span&gt;  : [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;shinygold&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;fadedblue&amp;#39;&lt;/span&gt;],
 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;shinygold&amp;#39;&lt;/span&gt;    :[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;darkolive&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;vibrantplum&amp;#39;&lt;/span&gt;],
 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;darkolive&amp;#39;&lt;/span&gt;    :[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;fadedblue&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;dottedblack&amp;#39;&lt;/span&gt;],
 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;vibtrantplum&amp;#39;&lt;/span&gt; :[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;fadedblue&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;dottedblack&amp;#39;&lt;/span&gt;]}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
The challenge comes when you see that many starting points can lead to
the goal of the shiny gold bag. &lt;/p&gt;
&lt;p&gt;
The insight comes when you notice that you can &amp;#34;reverse the edges.&amp;#34;
For example, when we saw the line that led to the lightred contains
brightwhite and mutedyellow, instead we represent it the other way
making two entries - brightwhite is contained by lightred and also
mutedyellow is contained by lightred. &lt;/p&gt;
&lt;p&gt;
Once we set this up the solution is a breadth or depth first search. &lt;/p&gt;
&lt;p&gt;
The video doesn&amp;#39;t do a complet walk through but goes into more
details. &lt;/p&gt;
&lt;p&gt;
I like this type of problem for classes because students can see that
sometimes changing the data can make the problem much easier. If you
implement the adjacency list as it&amp;#39;s presented the problem seems
hard. Once you see you can go from shinygold out instead of from  all
the bags to shinygold the porblem becomes much easier.&lt;/p&gt;
&lt;p&gt;
The other interesting point is that without fundamental data
structures and algorithms this is a hard problem. With them, it&amp;#39;s
pretty straightforward. Remind your students of this when they ask why
they need data structures and algorithms. This problem might be made
up but graphs represent a lot of things in the real world and graph
traversals and algorithms can solve a lot of real world problems&lt;/p&gt;
&lt;p&gt;
Now to day 8. &lt;/p&gt;
&lt;p&gt;
Day 8 involved a simple machine simulator and leads to a very
straightforward solution - write a program that simulates the computer
stated in the problem. My solution tries to approach the problem in a
functional way and also makes use of a function lookup table to avoid
multiple ifs. The solution and complete walk through is in the video
and in Clojure but a similar solution can be written in Python.&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/IEjnnRhUAxg&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>A Teacher looks at Advent of Code 2020 - Day 06</title>
      <link>https://cestlaz.github.io/post/advent-2020-day06/</link>
      <pubDate>Sun, 06 Dec 2020 10:14:03 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day06/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2020/day/6&#34;&gt;Day 6&lt;/a&gt; turned out to be pretty straightforward. Like day 4 you had to
deal with two consecutive newlines when parsing the data but assuming
you did day 4 that&amp;#39;s no problem. &lt;/p&gt;
&lt;p&gt;
The gist is that a group is formed by consecutive lines and groups are
separated by a blank line. Each line in each group is a string of
letters representing answers to questions. For instance, for this
group: &lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
abc
abd
ab
&lt;/pre&gt;
&lt;p&gt;
you have three people. The first answered &amp;#39;yes&amp;#39; to a, b, and c. the
second to a,b, and d and the third to a and b. &lt;/p&gt;
&lt;p&gt;
Your goal was to figure out how many different questions did each
group answer &amp;#39;yes&amp;#39; to and what was the total across the groups. &lt;/p&gt;
&lt;p&gt;
It seemed that the easiest thing to do was to take each group, remove
the newlines and then count the unique characters. &lt;/p&gt;
&lt;p&gt;
In Python, something like this (Clojure in the video and on &lt;a href=&#34;https://github.com/zamansky/advent2020/blob/main/src/day06.clj&#34;&gt;GitHub&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;d&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abc&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;abd&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;ab&amp;#34;&lt;/span&gt;
d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; d&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;replace(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;)
s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set(d)
ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len(s)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
So, you just have to do that for each group and add them all up.&lt;/p&gt;
&lt;p&gt;
Part 2 added a small twist. Now you wanted to look at each group and
count the number of answers that everyone in that group answered &amp;#34;yes&amp;#34;
to. For the above example, it would be 2 - everyone answered a and b.&lt;/p&gt;
&lt;p&gt;
Assuming your language supports set operations, you can just use
union.&lt;/p&gt;
&lt;p&gt;
Again in Python: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abc&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;abd&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;ab&amp;#34;&lt;/span&gt;
d_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; d&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()
result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set(d_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])

&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; d_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:]:
    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; set(item)
print(result)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Again,  do it for all the groups and add it up.&lt;/p&gt;
&lt;p&gt;
This is a great question to go over set operations!!&lt;/p&gt;
&lt;p&gt;
Check out the Clojure video for that approach where I also talk about
easier ways to complete yesterday&amp;#39;s problem.&lt;/p&gt;
&lt;p&gt;
Enjoy!&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/I8dbKJ_315Q&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>A teacher looks at Advent of Code 2020 - Day 5</title>
      <link>https://cestlaz.github.io/post/advent-2020-day05/</link>
      <pubDate>Sat, 05 Dec 2020 11:18:59 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day05/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2020/day/5&#34;&gt;Day five&amp;#39;s problem&lt;/a&gt; is a nice one for an early CS class. It can be very
much brute forced but it also touches on some nice concepts and can be
solved pretty elegantly. I&amp;#39;ve embedded a walk through in Clojure at
the end but a Python solution would be pretty similar.  &lt;/p&gt;
&lt;p&gt;
Read the problem over if you haven&amp;#39;t. At it&amp;#39;s core you are taking a boarding
pass representing a coded airplane seat number and you&amp;#39;re converting
it to a known seat (row and column). The encoding scheme uses &lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_space_partitioning&#34;&gt;binary
space partitioning&lt;/a&gt;. The &lt;a href=&#34;https://adventofcode.com/2020/day/5&#34;&gt;question statement&lt;/a&gt; goes over the details.&lt;/p&gt;
&lt;p&gt;
One of the first things to notice is that you should separate the pass
into two parts - the row, which consists of the first seven characters
each one being an &lt;strong&gt;F&lt;/strong&gt; or a &lt;strong&gt;B&lt;/strong&gt; and the last three which are the
columns and they are marked with either a &lt;strong&gt;R&lt;/strong&gt; or an &lt;strong&gt;L&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;
So, the sample pass &lt;strong&gt;FBFBBFFRLR&lt;/strong&gt; separates into &lt;strong&gt;FBFBBFF&lt;/strong&gt; for the row
and &lt;strong&gt;RLR&lt;/strong&gt; for the clumn.&lt;/p&gt;
&lt;p&gt;
There are 128 rows numbered 0 through 127 so you start with 127 (the
back of the plane) and then depending on if the next character is an
&lt;strong&gt;F&lt;/strong&gt; or a &lt;strong&gt;B&lt;/strong&gt; you either subtract out half the range size or you
don&amp;#39;t. If the character is an &lt;strong&gt;B&lt;/strong&gt; you don&amp;#39;t since you&amp;#39;re at the back
of the section and the back rows are higher. If it&amp;#39;s a &lt;strong&gt;F&lt;/strong&gt; you do
since you&amp;#39;re at the front and front rows have lower numbers.&lt;/p&gt;
&lt;p&gt;
So, the first &lt;strong&gt;F&lt;/strong&gt; says you&amp;#39;re at the front so you subtract &lt;strong&gt;half&lt;/strong&gt; the
range and now you&amp;#39;re looking at 0-63. The next character is a &lt;strong&gt;B&lt;/strong&gt; so
you don&amp;#39;t subtract anything but you&amp;#39;ll be next looking at 32 through
63 etc. The question has a full walk through.&lt;/p&gt;
&lt;p&gt;
Looking at the  row string, you have &lt;strong&gt;FBFBBFF&lt;/strong&gt;. If we substitute the
amount we subtract for the letters we get &lt;code&gt;64 0 16 0 0 2 1&lt;/code&gt; or the
place values of a binary number &lt;strong&gt;in reverse&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;
In my solution, I reversed the string and then converted each &lt;strong&gt;F&lt;/strong&gt; or &lt;strong&gt;B&lt;/strong&gt;
into a number. A &lt;strong&gt;B&lt;/strong&gt; became a 0 and an &lt;strong&gt;F&lt;/strong&gt; became 2^i where &lt;strong&gt;i&lt;/strong&gt; is the
location (index) in the string. For the sample string, once reversed
to &lt;strong&gt;FFBBFBF&lt;/strong&gt; it gives &lt;code&gt;1 2 0 0 16 0 64&lt;/code&gt;. If we sum those up and
subtract from 127 we get our row number.&lt;/p&gt;
&lt;p&gt;
We basically can do the same thing for the column but there you
subtract from 7.&lt;/p&gt;
&lt;p&gt;
Part 1 of the question asks you to map the row and column to a final
number by calcualing &lt;code&gt;row*8+col&lt;/code&gt; and then find the highest seat number
from a give list of boarding passes.&lt;/p&gt;
&lt;p&gt;
Part 2 requires you look through all the boarding passes to determine
your actual seat - the one seat missing from the data set.&lt;/p&gt;
&lt;p&gt;
Lots of good stuff for a class in this question.&lt;/p&gt;
&lt;p&gt;
You&amp;#39;ve got the basic data parsing as usual but I love that this can be
brute forced but by noticing the base 2 nature of the data you can
write up a number of different elegant solutions. &lt;/p&gt;
&lt;p&gt;
Here&amp;#39;s a complete solution coded up in Clojure. You can also check all
my Advent of Code solutions up on GitHub
&lt;a href=&#34;https://github.com/zamansky/advent2020&#34;&gt;https://github.com/zamansky/advent2020&lt;/a&gt;. &lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/lq5AdWkzyjg&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>A Teacher Looks at Advent of Code 2020 - Day 4</title>
      <link>https://cestlaz.github.io/post/advent-2020-day04/</link>
      <pubDate>Fri, 04 Dec 2020 17:31:06 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day04/</guid>
      <description>&lt;p&gt;
One of the nice things about Advent of Code is that it gets me to
explore language features I haven&amp;#39;t used yet. Today&amp;#39;s problem got me
to explore Clojure Spec which is a very cool validation
library. There&amp;#39;s a complete run through of the solution in Clojure in
the video but here I&amp;#39;ll talk about the problem in Python (mostly). &lt;/p&gt;
&lt;p&gt;
Today&amp;#39;s &lt;a href=&#34;https://adventofcode.com/2020/day/4&#34;&gt;problem&lt;/a&gt; is about validating passports. You start with a text
file consisting of passport information. Each passport is one or more
lines with each line having a bunch of key value pairs. For example,
these two lines represent a passport for someone who&amp;#39;s eye color (ecl)
is gray (gry) and who was born (byr) in 1937:&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
ecl:gry pid:860033327 eyr:2020 hcl:#fffffd
byr:1937 iyr:2017 cid:147 hgt:183cm
&lt;/pre&gt;
&lt;p&gt;
The catch is that one passport can span multiple lines and that
passports are separated by two consecutive newlines in the file.&lt;/p&gt;
&lt;p&gt;
A passport has 8 field types with one, Country of Origin (cid) being
optional.&lt;/p&gt;
&lt;p&gt;
For part 1, a valid passport is one that contains all 7 required
fields. &lt;/p&gt;
&lt;p&gt;
The video goes over a Clojure solution which, I think is cleaner but
the idea is the same as the Python I&amp;#39;ll talk about here.&lt;/p&gt;
&lt;p&gt;
Splitting the data into a list of potential passports is easy because
you can split the string on two newlines: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;../data/sample04.dat&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read()
data&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Now we have a list of string. &lt;/p&gt;
&lt;p&gt;
Next, we can split each string on whitespace so that each string in
each sublist is a string in the form &lt;strong&gt;k:v&lt;/strong&gt;: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;data_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; d &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
    data_list&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append([item &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; d&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
So, for example, data_list[0] might look like this: &lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
[&amp;#39;ecl:gry&amp;#39;, &amp;#39;pid:860033327&amp;#39;, &amp;#39;eyr:2020&amp;#39;, &amp;#39;hcl:#fffffd&amp;#39;, &amp;#39;byr:1937&amp;#39;, &amp;#39;iyr:2017&amp;#39;, &amp;#39;cid:147&amp;#39;, &amp;#39;hgt:183cm&amp;#39;]
&lt;/pre&gt;
&lt;p&gt;
Finally, we can convert each passport into a dictionary: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;data_dicts&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[]
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; d &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data_list:
    temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { item&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]:item&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; d} 
    temp&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pop(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;cid&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;)
    data_dicts&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(temp)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
The easiest way I came up with to check if a passport was valid was to
make a set out of a list of required field names, make a set out of
each potential passports field names (they&amp;#39;re dictionary keys) and see
if they&amp;#39;re equal: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;fields &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set([&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;byr&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;iyr&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;eyr&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hgt&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hcl&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ecl&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pid&amp;#34;&lt;/span&gt;])
valid_passports &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;  [set(x&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;keys()) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; fields &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data_dicts]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
I think the Clojure code is cleaner but it&amp;#39;s much the same.&lt;/p&gt;
&lt;p&gt;
Part two added a twist - you now have to not only see if the required
fields are there but you had to make sure they had valid data. For
example, height had to start with a positive integer followed by
either &lt;strong&gt;cm&lt;/strong&gt; or &lt;strong&gt;in&lt;/strong&gt;. If it was &lt;strong&gt;cm&lt;/strong&gt;, the number had to be in a certain
range and if it was &lt;strong&gt;in&lt;/strong&gt; it had to be within a different range. &lt;/p&gt;
&lt;p&gt;
This didn&amp;#39;t sound hard but could get tricky. For each field type you
could write a function that took in the value and returned true or
false depending on its validity - lots of ad hoc code. You could then
loop over all the passports and test to see if all the conditions were
met. &lt;/p&gt;
&lt;p&gt;
It turns out that Clojure has a really cool library - Clojure Spec
that does just that. You set up validators for each field type and
then one for an entire passport. Here&amp;#39;s the code: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::byr&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/and&lt;/span&gt; string? &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&amp;gt;= (&lt;span style=&#34;color:#a6e22e&#34;&gt;u/parse-int&lt;/span&gt; %) &lt;span style=&#34;color:#ae81ff&#34;&gt;1920&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&amp;lt;= (&lt;span style=&#34;color:#a6e22e&#34;&gt;u/parse-int&lt;/span&gt; %) &lt;span style=&#34;color:#ae81ff&#34;&gt;2002&lt;/span&gt;)))
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::iyr&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/and&lt;/span&gt; string? &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&amp;gt;= (&lt;span style=&#34;color:#a6e22e&#34;&gt;u/parse-int&lt;/span&gt; %) &lt;span style=&#34;color:#ae81ff&#34;&gt;2010&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&amp;lt;= (&lt;span style=&#34;color:#a6e22e&#34;&gt;u/parse-int&lt;/span&gt; %) &lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt;)))
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::eyr&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/and&lt;/span&gt; string? &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&amp;gt;= (&lt;span style=&#34;color:#a6e22e&#34;&gt;u/parse-int&lt;/span&gt; %) &lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&amp;lt;= (&lt;span style=&#34;color:#a6e22e&#34;&gt;u/parse-int&lt;/span&gt; %) &lt;span style=&#34;color:#ae81ff&#34;&gt;2030&lt;/span&gt;)))
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::hgt&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/and&lt;/span&gt; string? hgt-test))
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::hcl&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/and&lt;/span&gt; string? &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(re-find &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;#[0-9a-f]{6}&amp;#34;&lt;/span&gt; %)))
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::ecl&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/and&lt;/span&gt; string? &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(re-find &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;amb|blu|brn|gry|grn|hzl|oth&amp;#34;&lt;/span&gt; %)))
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::pid&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/and&lt;/span&gt; string? &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(re-find &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;^[0-9]{9}$&amp;#34;&lt;/span&gt; % )))
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::cid&lt;/span&gt; string?)
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::passport&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/keys&lt;/span&gt;
                   &lt;span style=&#34;color:#e6db74&#34;&gt;:req&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;::byr&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::iyr&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::eyr&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::hgt&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::hcl&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::ecl&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::pid&lt;/span&gt;]
                   &lt;span style=&#34;color:#e6db74&#34;&gt;:opt&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;::cid&lt;/span&gt;]))

(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/valid?&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::passport&lt;/span&gt; test-passport)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
The last line would test to see if &lt;strong&gt;test-passport&lt;/strong&gt; was valid. It&amp;#39;s all
covered in detail in the video.&lt;/p&gt;
&lt;p&gt;
Clojure spec wasn&amp;#39;t required for this problem but I&amp;#39;ve been meaning to
play with it for a while and it led to a clean and elegant way of
testing passports. &lt;/p&gt;
&lt;p&gt;
Not sure if I&amp;#39;ll get to more posts or even solve more problems - I&amp;#39;m
trying to limit my own screen time over the weekends but we&amp;#39;ll see.&lt;/p&gt;
&lt;p&gt;
If you want to check out all the Clojure goodness here it is: Enjoy!&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/QzdCrJgXsww&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>A Teacher Looks at Advent of Code 2020 - Day 3</title>
      <link>https://cestlaz.github.io/post/advent-2020-day03/</link>
      <pubDate>Thu, 03 Dec 2020 14:27:02 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day03/</guid>
      <description>&lt;p&gt;
I thought I&amp;#39;d do a video for today. No particular reason. Mostly why
not.&lt;/p&gt;
&lt;p&gt;
I&amp;#39;ll talk about day 3&amp;#39;s problem and code up a solution in Clojure. If
you haven&amp;#39;t ever used Clojure, hopefully this will give a bit of the
flavor. This video also serves double duty as being my next Using
Emacs video since it demos Emacs&amp;#39;s Clojure tools. Mostly Cider which
even with a few quirks is the best development environment I&amp;#39;ve ever
used. &lt;/p&gt;
&lt;p&gt;
I don&amp;#39;t know if I&amp;#39;ll do any more videos or blog posts on AOC this
year. I hope to but I&amp;#39;m going to have to get to end of semester
obligations soon so you never know.&lt;/p&gt;
&lt;p&gt;
Enjoy!&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/ecJ1TJGWrfs&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>A Teacher Looks at Advent of Code 2020 - Day 2</title>
      <link>https://cestlaz.github.io/post/advent-2020-day02/</link>
      <pubDate>Wed, 02 Dec 2020 12:27:27 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day02/</guid>
      <description>&lt;p&gt;
Day two introduced some staples of staples of not only Advent of Code but
also of programming problems in general. The first is input
parsing. For this problem you get lines of input like this:&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
1-3 a: abcde
1-3 b: cdefg
2-9 c: cccccccc
&lt;/pre&gt;
&lt;p&gt;
or in general&lt;/p&gt;
&lt;p&gt;
&lt;strong&gt;number_1&lt;/strong&gt;-&lt;strong&gt;number_2&lt;/strong&gt; &lt;strong&gt;Letter&lt;/strong&gt;: &lt;strong&gt;String&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;
There are a few ways to handle this. One is to brute force it. In
Python maybe something like: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;sample_line&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;4-15 f: abcdefg&amp;#34;&lt;/span&gt;
sample_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sample_line&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()
numbers&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sample_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
letter&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sample_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
string&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sample_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]

number_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; numbers&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;)
num1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(number_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])
num2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(number_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])

letter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; letter[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]

print(num1, num2, letter, string)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
or more concisely: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;sample_line&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;4-15 f: abcdefg&amp;#34;&lt;/span&gt;

(numbers,letter,string) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sample_line&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()

(num1,num2) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [int(x) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; numbers&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;)]

letter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; letter[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]

print(num1, num2, letter, string)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
If you&amp;#39;re working in a language like C, tools like &lt;code&gt;scanf&lt;/code&gt; can make
things easier. I generally turn to &lt;a href=&#34;https://blog.usejournal.com/regular-expressions-a-complete-beginners-tutorial-c7327b9fd8eb&#34;&gt;Regular Expressions&lt;/a&gt; and if you&amp;#39;re
doing some AOC with your classes this is a great time to introduce
regex. Basically, you set up a pattern with special symbols to
represent things like sequences of digits and then the regex matcher
does the hard work.&lt;/p&gt;
&lt;p&gt;
Here&amp;#39;s the code to &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;parser_expression&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;(\d+)-(\d+) ([a-z]): ([a-z]*)&amp;#34;&lt;/span&gt;
data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; line &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;../data/day02.dat&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;readlines():
    x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; re&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;search(parser_expression,line)
    (mini,maxi,letter,password) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;groups()
    mini &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(mini)
    maxi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(maxi)
    data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append([mini,maxi,letter,password])&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
The &lt;code&gt;parser_expression&lt;/code&gt; in line 1 is the regular expression. Each
section in parentheses is a &amp;#34;group&amp;#34; or a pattern that will be
extracted. The &lt;strong&gt;\d&lt;/strong&gt; for instance means a digit and the &lt;strong&gt;+&lt;/strong&gt; adger it
means 1 or more digits so basically that will match any positive
integer. The &lt;strong&gt;[a-z]&lt;/strong&gt; matches a single character and the *after the
final character match means zero or more of them. Once you know
regular expressions, parsing lines like this becomes very easy. The
only thing that made the above code messy at all was that I wanted to
convert the two numbers into integers rather than leave them as
strings. &lt;/p&gt;
&lt;p&gt;
There are a couple of things worth thinking about here. First is know
your libraries. If you know regex the parsing is basically all
done. If not, you have a bit of work. On the other hand, you&amp;#39;re
probably not going to ever have to parse input exactly like this again
so it doesn&amp;#39;t make sense writing a super robust set of  parsing
functions tied in with this data specification. That&amp;#39;s the second
thing. Learning what to leave as building blocks and what to write
into libraries of your own. It&amp;#39;s most definitely worth writing a set
of routines that can be reused. Maybe something to parse dates in a
standard format would be an example. On the other hand, it&amp;#39;s also
worth knowing when you probably won&amp;#39;t be able to reuse things or when
generalizing to a library or set of functions you have to spend too
much time on a hundred options to make in general purpose.&lt;/p&gt;
&lt;p&gt;
Now, part 1 of the problem itself is nice because there are a lot of
ways to do it. You could loop through the password and count the
number of times a letter occurs: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
subpassword &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; password[mini&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,maxi]
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; letter &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; subpassword:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; letter &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; what_im_looking_for:
        count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
or with a list comprehension &lt;code&gt;count = [x for x in password if x ==
waht_im_looking_for ]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;
You could be more general and build a hash table of counts and then
pull what you want: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;frequencies&lt;/span&gt;(word):
    d&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{}
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; letter &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; word:
        d&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;setdefault(letter,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
        d[letter]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;d[letter]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; d&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
This is admittedly overkill for the problem but one might need this
for part 2. I coded my original solution in Clojure and Clojure has a
function that does this in one shot: &lt;code&gt;frequencies&lt;/code&gt; so I just used that
and pulled the letter I needed.&lt;/p&gt;
&lt;p&gt;
Once you have the count, it&amp;#39;s simple enough to see if it&amp;#39;s in the
range.&lt;/p&gt;
&lt;p&gt;
Part 2 should have been easy but for me it was a lesson in
reading. You had to pull characters from the password at two specific
indices and see if one or the other, but not both were the letter in
question. Basically an xor. The first mistake one could make has to do
with the indexing and the second in using a regular or which students
will be more familiar with. &lt;/p&gt;
&lt;p&gt;
My mistake is that I misread the question as requiring that you have
one instance of the letter within the &lt;strong&gt;range&lt;/strong&gt; from the low index to
the high index not one instance at either of those two points Needless
to say, lots of wasted time and feeling silly. &lt;/p&gt;
&lt;p&gt;
So that&amp;#39;s day 2. The question is very approachable for APCS-A  and I&amp;#39;d
say even CS0 students. The interesting part to teach would be dealing
with the input, regular expressions, and how much to generalize into
utility functions when writing code over time.&lt;/p&gt;
&lt;p&gt;
Hope to have time to solve and write up more of these but getting to
crunch time in the semester.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Teacher Looks at Advent of Code 2020 - Day 1</title>
      <link>https://cestlaz.github.io/post/advent-2020-day-01/</link>
      <pubDate>Tue, 01 Dec 2020 09:03:39 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day-01/</guid>
      <description>&lt;p&gt;
So, yesterday I was chatting with my daughter. She was talking with
her team and for some reason one of them pulled out an interview
question from their company&amp;#39;s question bank. Turns out it was today&amp;#39;s
Advent of Code problem. &lt;/p&gt;
&lt;p&gt;
As with past years, I&amp;#39;m going to try to solve the problems in Clojure
but if I can will talk Python when I talk about solutions. &lt;/p&gt;
&lt;p&gt;
Part 1 of the problem basically asks for you to find a pair of numbers
in an array that sum to a specific value. In this case 2020. Figuring
that this was day 1 I didn&amp;#39;t expect a crazy large data set or any
other tricks or weirdness - a straightforward solution should
suffice. Simply a loop within a loop and sum up all the pairs: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt;:
      print(x&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;y)&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Nothing fancy but it gets the job done. It does print out the answer
twice since x and y both go through all the indices but that&amp;#39;s no big
deal.&lt;/p&gt;
&lt;p&gt;
The part 2 twist was that now you were looking for a set of three
entries that added up to 220. Once again, not a big deal: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; z &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;z &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt;:
                print(x&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;z)&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
As before, you&amp;#39;ll get multiple answers but no big deal.&lt;/p&gt;
&lt;p&gt;
What I like about this one is that you can think about this as a
looping exercise as above but you can also think about it as a list
processing exercise, that is, by thinking about it with more of a
functional programming bent. &lt;/p&gt;
&lt;p&gt;
The key insight here is that the question was clear in that there will
only be one pair in part 1 that satisfies the problem and likewise
only one pair in part 2. &lt;/p&gt;
&lt;p&gt;
If we look at each item in our data set, it&amp;#39;s part of the answer if
and only if there&amp;#39;s another number in the set equal to 2020 minus that
item. This leads to a list comprehension&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;part1_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [x &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data]&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Now, part1_list should contain the two items we need. The first value &lt;code&gt;x&lt;/code&gt;
was found when the comprehension saw that &lt;code&gt;2020 - x&lt;/code&gt; was in the list
and &lt;code&gt;2020-x&lt;/code&gt; which is the second value was confirmed when the for part
of the comprehension gets to it and finds that the first item is in
the list. Then, it&amp;#39;s a simple matter of just multiplying the two
numbers together for the answer.&lt;/p&gt;
&lt;p&gt;
Part 2 is similar but you can use a list comprehension to iterate over
all pairs of elements and then you calculate the third:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;part2_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [x &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;(x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y) &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data]&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Of course you could have put &lt;code&gt;y&lt;/code&gt; or &lt;code&gt;2020-(x+y)&lt;/code&gt; in place of that
first &lt;code&gt;x&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;
Part 2 has an additional subtlety in that you&amp;#39;ll get the solution
multiple times which makes sense you&amp;#39;re hitting each triple multiple
times. To fix that, turn it into a set: &lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;part2_set &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set(part2_list)&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
and then calculate the product.&lt;/p&gt;
&lt;p&gt;
At the core, both of these solutions are really the same but you get
to them by thinking very differently. The first one is all about the
loops - thinking about data[i] at a very low discrete level. The
second approach is thinking about the data as a list and processing
that list at a much higher level. This could be an ice problem to
transition between the two approaches.&lt;/p&gt;
&lt;p&gt;
Looking forward to what tomorrow&amp;#39;s problem brings.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2020</title>
      <link>https://cestlaz.github.io/post/advent-2020-leadin/</link>
      <pubDate>Mon, 30 Nov 2020 14:21:17 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-leadin/</guid>
      <description>&lt;p&gt;
Tomorrow, or more practically, tonight at Midnight,  &lt;a href=&#34;https://twitter.com/ericwastl&#34;&gt;Eric Wastl&lt;/a&gt; will
once again launch the &lt;a href=&#34;https://adventofcode.com&#34;&gt;Advent of Code&lt;/a&gt;. As I&amp;#39;ve written before, it&amp;#39;s a
month long event where each day a new programming problem is
released. The problems range in difficulty and complexity. Some are
very approachable to beginners and some are crazy challenging. I&amp;#39;ve
written a bunch about AOC in past years:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/solve-a-to-solve-b/&#34;&gt;Solve A to Solve B&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/aoc-data-structures-hidden-complexity/&#34;&gt;Data structures and Hidden Complexity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/posts/advent-2017-4-6/&#34;&gt;Tools can shape- how we think&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day1/&#34;&gt;2019 day 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day2/&#34;&gt;2019 day 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day3/&#34;&gt;2019 day 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day4/&#34;&gt;2019 day 4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day8/&#34;&gt;2019 day 8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day8-part2/&#34;&gt;2019 day 8 addendum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
and a few more not listed.&lt;/p&gt;
&lt;p&gt;
If you haven&amp;#39;t heard of AOC, at the stroke of midnight (Eastern), a
new problem is released. From there you can read the problem, get the
input and figure out a solution, usually by writing a program. You
then type in your answer and if it&amp;#39;s correct you get part 2 - usually
a creative spin on part one. Usually you&amp;#39;ll write a program to solve
the problems but sometimes you&amp;#39;ll write code just to explore and come
up with an answer. &lt;/p&gt;
&lt;p&gt;
Even though there&amp;#39;s a leader board and people can set up their own
private leader boards, I describe AOC as an event not as a
competition. I&amp;#39;ve had former students up near the top but a getting
there requires a lot more than just problem solving. First, you have
to be up when the problem is released, then you have to shortcut scan
what the question is asking. Having a library of pre-written utility
routines is a big help as is using a language that has a lot of
interactive scripty functionality like Python. It also assumes that
even if you do all that is needed, that life doesn&amp;#39;t get in the
way. This means that to get to the top of the leader board, like in
most competitions you have to train and prepare to do just that and
training for that doesn&amp;#39;t really translate to the rest of life&amp;#39;s
challenges.&lt;/p&gt;
&lt;p&gt;
Solving the problems, though, can translate to other challenges you
might face so I look at AOC as an opportunity to explore some
interesting problems. &lt;/p&gt;
&lt;p&gt;
I&amp;#39;ve never finished all of them and that&amp;#39;s okay. Here&amp;#39;s my star count
for each of the years. You get one star for each part of each question
so that&amp;#39;s 50 total.&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Year:&lt;/strong&gt;&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2015&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2016&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2017&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2018&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2019&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Stars:&lt;/strong&gt;&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;26&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;40&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;11&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;23&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;31&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
I&amp;#39;ve never gotten more than 40. I typically wake up and read the
question and see if I can solve it either then or over the course of
the day. Sometimes I&amp;#39;ll come back to a problem but usually not. Last
year, many problems were based on earlier ones. I had an issue in one
of those earlier solutions so never completed the later ones. &lt;/p&gt;
&lt;p&gt;
Maybe I&amp;#39;ll go back and finish more, maybe I won&amp;#39;t.&lt;/p&gt;
&lt;p&gt;
None of this matters. &lt;/p&gt;
&lt;p&gt;
I had fun, learned a lot and as an added bonus, each problem gives me
an opportunity to reflect on how I might teach it or teach concepts
related to it.&lt;/p&gt;
&lt;p&gt;
It all starts in a few hours so if you&amp;#39;re already planning on
participating, have a blast. If you haven&amp;#39;t, check it out.&lt;/p&gt;
&lt;p&gt;
Advent of code can be found here: &lt;a href=&#34;https://adventofcode.com&#34;&gt;https://adventofcode.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
And, the AOC subreddit, which is great for problem discussions can be
found here: &lt;a href=&#34;https://www.reddit.com/r/adventofcode/&#34;&gt;https://www.reddit.com/r/adventofcode/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
Enjoy. &lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Multi Stage Assignments - the good and the bad - Advent of Code</title>
      <link>https://cestlaz.github.io/post/multi-stage-assignments/</link>
      <pubDate>Thu, 12 Dec 2019 17:19:27 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/multi-stage-assignments/</guid>
      <description>&lt;p&gt;
In the real world you&amp;#39;re usually not building your own projects from
scratch. Much more frequently you&amp;#39;re working on a team and you and
other players come and go over time. &lt;/p&gt;
&lt;p&gt;
This is in stark contrast to most CS educational experiences where
students typically complete relatively small assignments from
beginning to end. One of my biggest fears way back when as I was about
to graduate college was when I woke up one night in a cold sweath &amp;#34;oh
crap - in a couple of weeks I&amp;#39;m going to have to actually produce good
code. Not just code good enough to get by the grader.&amp;#34;&lt;/p&gt;
&lt;p&gt;
So, as a general rule,  having students build a project and then later
extend it or, even better, having them extend another student&amp;#39;s project
can be a very good experience. On the other hand, it can also be a
very bad one.&lt;/p&gt;
&lt;p&gt;
It&amp;#39;s a great feeling when you leverage a previous project to create
something new. On the other hand, there can be tremendous frustration
if the original project forms a faulty foundation and you have to go
back and rebuild and even then you&amp;#39;re never 100% sure that you&amp;#39;re
building on a solid base.&lt;/p&gt;
&lt;p&gt;
Building on a previous project has been big in this years &lt;a href=&#34;http://adventofcode.com&#34;&gt;Advent of
Code&lt;/a&gt;. It started with &lt;a href=&#34;https://adventofcode.com/2019/day/2&#34;&gt;day 2&lt;/a&gt; when we were asked to write a simple
computer that ran &amp;#34;intcode programs.&amp;#34; Not a bad little challenge. It
then returned in &lt;a href=&#34;https://adventofcode.com/2019/day/5&#34;&gt;day 5&lt;/a&gt; where we had to add a number of features to our
intcode machines. This too was a nice assignment. It had to be built
on a correct and complete day 2 solution but as far as I could tell,
regardless of how you completed day 2 there was a straightforward way
to extend it to integrate the requirements for day 5.&lt;/p&gt;
&lt;p&gt;
Things got interesting in &lt;a href=&#34;https://adventofcode.com/2019/day/7&#34;&gt;day 7&lt;/a&gt; and this is where a teacher, or
competition designer for that matter has to start being careful. Day 5
had us modify and build on day 2 but day 7 had us &lt;strong&gt;use&lt;/strong&gt; what we
created in days 2 and 5. From a teacher who&amp;#39;s building assignments
point of view, this changes the equation. Day 2 and 5 had you build
something that took some input and produced some output. Now, in day 7
you had to do something on top of your intcode machine, feed it into
it (or them as it turned out) and get an output. Depending on the
assumptions you made in building your intcode machine you would either
have an easy time with day 7 or you&amp;#39;d have to go back and redo day 2
and/or 5 - much less fun. As part 2 of day 7 had us running multiple
intcode machines &amp;#34;simultaneously,&amp;#34; my set up didn&amp;#39;t work. I still have
to go back and finish that problem.&lt;/p&gt;
&lt;p&gt;
Herein lies a big problem with multi part assignments. Unless you
really lay out the parameters of the early assignment students can,
and frequently will make assumptions you never dreamed of. Those
assumptions can make their lives easier in parts 2 and beyond but it
can also leave them with an impossible task. This on top of any
student that doesn&amp;#39;t finish the early version to begin with.&lt;/p&gt;
&lt;p&gt;
Moving on, &lt;a href=&#34;https://adventofcode.com/2019/day/9&#34;&gt;day 9&lt;/a&gt; added some more features to the intcode machine and
since then, days &lt;a href=&#34;https://adventofcode.com/2019/day/11&#34;&gt;11&lt;/a&gt;, &lt;a href=&#34;https://adventofcode.com/2019/day/13&#34;&gt;13&lt;/a&gt;, &lt;a href=&#34;https://adventofcode.com/2019/day/15&#34;&gt;15&lt;/a&gt;, &lt;a href=&#34;https://adventofcode.com/2019/day/17&#34;&gt;17&lt;/a&gt;, and &lt;a href=&#34;https://adventofcode.com/2019/day/19&#34;&gt;19&lt;/a&gt; have all used our intcode
machine. I&amp;#39;ve had issues with my machine for days 11 and 13 and have
to fix my intcode machine&amp;#39;s input/output handling to finish those
challenges but my machine worked well enough to complete days 15, 17,
and 19.&lt;/p&gt;
&lt;p&gt;
So, at the end of the day building on a previous project can be very
cool and for a student very rewarding but it can also be really
challenging. On top of the issue I&amp;#39;ve already talked about this can
also leave students in a very uneasy state when extending a project by
using it rather than building on it. Did they write the early parts
fully correctly or just enough to get by the early test cases? It can
be very unsettling to work on an uncertain foundation. What&amp;#39;s more,
while a teacher can even provide base code, this might only be useful
to help check results as now having a student use provided code adds
yet another challenge (albeit one that provides many useful lesosns).&lt;/p&gt;
&lt;p&gt;
As to doing this in Advent of Code? I doubt &lt;a href=&#34;https://twitter.com/ericwastl&#34;&gt;Eric Wastl&lt;/a&gt; and the other
organizers will read this but in case they do, this isn&amp;#39;t a complaint
about Advent of Code. I love the event and we can all quibble about
details we like or don&amp;#39;t like. Advent of Code also isn&amp;#39;t a class with
a grade and if I never finish, let&amp;#39;s say, day 11, there are no
consequences - unlike if a student doesn&amp;#39;t finish part 2 of a graded
project. &lt;/p&gt;
&lt;p&gt;
I&amp;#39;m writing this because I think there are some interesting parallels
between creating an event like Advent of Code and designing projects
and lessons for students and more interestingly , where those //s
diverge.&lt;/p&gt;
&lt;p&gt;
Now to get to grading. Hoping to get done to spend at least a few
minutes on &lt;a href=&#34;https://adventofcode.com/2019/day/20&#34;&gt;day 20&lt;/a&gt;. &lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent 2019 Day 8 - addendum - generating inputs</title>
      <link>https://cestlaz.github.io/post/advent-2019-day8-part2/</link>
      <pubDate>Sun, 08 Dec 2019 17:04:30 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2019-day8-part2/</guid>
      <description>&lt;p&gt;
As I said in my &lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day8/&#34;&gt;last post&lt;/a&gt;, &lt;a href=&#34;https://adventofcode.com/2019/day/8&#34;&gt;day 8&lt;/a&gt; would be a nice project or lesson in
an APCS-A or college CS1 class. Another nice problem would be to
write a program to generate an image in the format required by the
question. Alternatively, a teacher doing day 8 with their classes
might want to generate a bunch of images for the students to test
their decoders on. &lt;/p&gt;
&lt;p&gt;
I thought I&amp;#39;d write one to see how appropriate it would be for the
students. I tried to do it without anything fancy or advanced.&lt;/p&gt;
&lt;p&gt;
To start, you&amp;#39;ll need a way to generate the block text for the
images. I found &lt;a href=&#34;http://www.patorjk.com/software/taag/#p=display&amp;amp;f=Banner3&amp;amp;t=Hello&#34;&gt;this&lt;/a&gt; site and used the &lt;strong&gt;Banner3&lt;/strong&gt; font. I generated
some text and saved it in a file. The important thing for our purposes
is that any space will count as white and any character as black.&lt;/p&gt;
&lt;p&gt;
The encoded image is a N * Width * Height sequence of digits  where
each Width * Height sequence of digits represents one layer. See the
&lt;a href=&#34;https://adventofcode.com/2019/day/8&#34;&gt;problem text&lt;/a&gt; for details.&lt;/p&gt;
&lt;p&gt;
You can follow along with the code &lt;a href=&#34;https://github.com/zamansky/advent2019/blob/master/day08-generator.py&#34;&gt;here&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;
So, here&amp;#39;s how the program works:&lt;/p&gt;
&lt;p&gt;
The top 51 lines of the program consist of a routine which I&amp;#39;ll
describe later and code to handle command line argument (to set the
number of layers).&lt;/p&gt;
&lt;p&gt;
Then, on line 55 I erad  in the file with the source image (from stdin). &lt;/p&gt;
&lt;p&gt;
In line 57 through 63, I loop over the data and changed each non space
or newline to a star character. I really don&amp;#39;t have to do this but I
wanted to see what the image looked like in just &amp;#34;black and white.&amp;#34;&lt;/p&gt;
&lt;p&gt;
Line 65 through 67 is where I split on the newlines. Now I could take
the length of any line to get the image width and the number of lines
the height.&lt;/p&gt;
&lt;p&gt;
70 through 79 creates a long list for the image. At each location, I
generate a list of values. Each list has one entry per layer. The
actual pixel value (1 or 0) is stored at a random location. Everything
before that is a random choice between the real color and transparent
and everything after is just random. Details for that step are in the
&lt;code&gt;genpixel&lt;/code&gt; routine.&lt;/p&gt;
&lt;p&gt;
Finally, in 83 through 89 I loop over each layer and for each layer
the image and and output all the values into a single string. &lt;/p&gt;
&lt;p&gt;
This is then output to stdout while the dimensions go to stderr.&lt;/p&gt;
&lt;p&gt;
If I had a source image in a file named &amp;#34;hello.dat&amp;#34; I&amp;#39;d convert it to
source input for day 8 by typing &lt;code&gt;cat hello.dat | python3 day08-generator.py
-l 10 &amp;gt; day08-input.dat&lt;/code&gt;. This would create a 10 layer input.&lt;/p&gt;
&lt;p&gt;
That&amp;#39;s it. Once again, the code is all &lt;a href=&#34;https://github.com/zamansky/advent2019/blob/master/day08-generator.py&#34;&gt;here&lt;/a&gt;. It would make for another
nice student assignment or for a teacher to prepare inputs for the
class.&lt;/p&gt;
&lt;p&gt;
Enjoy.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent 2019 Day - 8</title>
      <link>https://cestlaz.github.io/post/advent-2019-day8/</link>
      <pubDate>Sun, 08 Dec 2019 08:42:32 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2019-day8/</guid>
      <description>&lt;p&gt;
I spent most of last week up in Albany working on the NY State K12 CS
Standards so fell a bit behind. I had to go back to complete &lt;a href=&#34;https://adventofcode.com/2019/day/5&#34;&gt;day 5&lt;/a&gt; but
still haven&amp;#39;t finished &lt;a href=&#34;https://adventofcode.com/2019/day/7&#34;&gt;day 7&lt;/a&gt; which builds on day 5 which in turn
builds on &lt;a href=&#34;https://adventofcode.com/2019/day/2&#34;&gt;day 2&lt;/a&gt;. I might not get to finishing 7 for a while but it
looks like a good chance to play with &lt;a href=&#34;https://www.braveclojure.com/core-async/&#34;&gt;core.async&lt;/a&gt; - Clojure&amp;#39;s
facilities for concurrency. I also want to write up &lt;a href=&#34;https://adventofcode.com/2019/day/6&#34;&gt;day 6&lt;/a&gt; but today
let&amp;#39;s look at &lt;a href=&#34;https://adventofcode.com/2019/day/8&#34;&gt;day 8&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
Day 8 is image processing problem so it fits nicely into an APCS-A
type class. You&amp;#39;re given the height and width of the image and you&amp;#39;re
told that the image comes in layers. The input is a long string of
digits. So, if you&amp;#39;re told that the width is 5 and height is 3 you
might get this as your input representing an image with 3 layers:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;100210120100120001102020112100000121002110102&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Adding commas and spaces:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;10021,01201,00120   00110,20201,12100   00012,10021,10102&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
The first part of the task is to find the layer with the most 0s and
return the number of 1s multiplied with the number of 2s.&lt;/p&gt;
&lt;p&gt;
This is just a nice little data parsing problem. You have to break the
input into &lt;code&gt;width*height&lt;/code&gt; chunks, see which has the most zeros, count
the ones and the twos and return the result. &lt;/p&gt;
&lt;p&gt;
Part 2 is where the image stuff comes in. We&amp;#39;re told that a color
value of 0 is black, 1 is white, and 2 is transparent. We&amp;#39;re also told
that the image&amp;#39;s actual color is the first color it sees (black or
white) when going through the layers. Depending on how you read in
your data, this could be easy or hard. You have to scan down the
layers and keep the first non-transparent color. &lt;/p&gt;
&lt;p&gt;
For part 1, I read my data into a list of lists where each item was a
layer. I did this in Clojure, but the Python representation of the
sample image above might look something like this:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;[ [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;],
  [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;],
  [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
There was no reason to subdivide each layer into rows and columns.&lt;/p&gt;
&lt;p&gt;
For part 1, I wanted to have lists where each list was all the values
of each pixel across the layers. This meant &lt;a href=&#34;https://en.wikipedia.org/wiki/Transpose&#34;&gt;transposing&lt;/a&gt; the matrix -
tat is, if you look at the above list of lists as a matrix, switching
the rows and columns. This was pretty easy to do in Clojure using
&lt;code&gt;(apply mapv vector matrix)&lt;/code&gt; but it shouldn&amp;#39;t be too hard in other
languages.&lt;/p&gt;
&lt;p&gt;
Next, we have to keep the first non-transparent color we see in each
list.&lt;/p&gt;
&lt;p&gt;
The final fun part is then taking the colors and printing out the
final image.&lt;/p&gt;
&lt;p&gt;
Here&amp;#39;s what I got:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;XXX  XXXX  XX   XX  X  X 
X  X X    X  X X  X X X  
X  X XXX  X    X  X XX   
XXX  X    X    XXXX X X  
X    X    X  X X  X X X  
X    X     XX  X  X X  X &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
What&amp;#39;s nice about this problem from a teacher&amp;#39;s point of view? First,
it&amp;#39;s the puzzle aspect of finding the hidden text. Second, it&amp;#39;s an
image problem which in APCS-A usually means 2D arrays but you can also
solve it without any 2D matrices. My solution involved a bunch of
filtering of data and the matrix transpose. Both interesting concepts
to bring to your classes.&lt;/p&gt;
&lt;p&gt;
If you want to see my Clojure solution, you can find it &lt;a href=&#34;https://github.com/zamansky/advent2019/blob/master/day08.clj&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent 2019 Day 4</title>
      <link>https://cestlaz.github.io/post/advent-2019-day4/</link>
      <pubDate>Wed, 04 Dec 2019 19:32:34 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2019-day4/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2019/day/4&#34;&gt;Day 4&lt;/a&gt;. Most of the day was spent working on the NY State CS standards
to I didn&amp;#39;t figure to have much time to work on the
problem. Fortunately, I was able to knock out part 1 before work
started and part 2 was a quick adjustment when I got back to it at the
start of lunch.&lt;/p&gt;
&lt;p&gt;
Once again, it was a problem with a few interesting teacher side
aspects.&lt;/p&gt;
&lt;p&gt;
I only wrote a &lt;a href=&#34;https://github.com/zamansky/advent2019/blob/master/day04.clj&#34;&gt;Clojure solution&lt;/a&gt; today so that&amp;#39;s what I&amp;#39;ll use for my
code examples.&lt;/p&gt;
&lt;p&gt;
The gist was that you were going to use a 6 digit integer as a
password but only  subset of the numbers between a start and end
point. Only numbers in that range for which these two properties held:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;There were at least one repeated digit, that is 123445 is o since
we have two consecutive 4s but 124354 isn&amp;#39;t&lt;/li&gt;
&lt;li&gt;The digits are increasing. That is, given any digit, the digit to
its right has either the same or a greater value.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You had to find the number of &amp;#34;valid passwords.&amp;#34;&lt;/p&gt;
&lt;p&gt;
At first read this sounds like a math problem but it really
isn&amp;#39;t. Looking at the first constraint, if you convert the number to a
string, looking to see that at least two consecutive characters are
the same is pretty easy - it&amp;#39;s just a simple loop. &lt;/p&gt;
&lt;p&gt;
It turns out that it&amp;#39;s even easier using &lt;a href=&#34;https://www.regular-expressions.info/&#34;&gt;Regular Expressions&lt;/a&gt;. Regular
expressions (regex) aren&amp;#39;t usually an explicit part of a CS sequence
but man are they useful. Basically they allow you to set up a pattern
that will match text. Some examples:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;pattern&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Matches&lt;/th&gt;
&lt;th&gt;doesn&amp;#39;t match&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;aa[0-9]bb&lt;/td&gt;
&lt;td&gt;Matches aa a digit than bb&lt;/td&gt;
&lt;td&gt;aa3bb&lt;/td&gt;
&lt;td&gt;ax3b, aacbb&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a+bb[a-z]&lt;/td&gt;
&lt;td&gt;one or more of a then two b then an a-z&lt;/td&gt;
&lt;td&gt;aabbc&lt;/td&gt;
&lt;td&gt;aabcb&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
You can use parentheses to form a &amp;#34;match group&amp;#34; and then use &amp;#34;\1&amp;#34; to
match the group, so this regular expression:&lt;/p&gt;
&lt;p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-regex&#34; data-lang=&#34;regex&#34;&gt;([0-9])\1&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;
will match two any substring with two of digits, adjacent. Many regex
engines allow you to use &lt;strong&gt;\d&lt;/strong&gt; instead of &lt;strong&gt;[0-9]&lt;/strong&gt; as a shorthand for
match a single digit.&lt;/p&gt;
&lt;p&gt;
Here&amp;#39;s the line that will take a list of potential passwords in a
variable &lt;strong&gt;passwords&lt;/strong&gt; and return a list that only containsn the
passwords that meet the two consecutive of the same digit rule.&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;(filter &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(re-seq &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;(\d)\1&amp;#34;&lt;/span&gt; %) passwords)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
I knew that Python has a &lt;strong&gt;partition&lt;/strong&gt; function that would take a string
with a potential password (I convert the number to a string before
doing the regex test above). It would take a string &amp;#34;1245&amp;#34; and convert
it into something like this &lt;strong&gt;(1,2), (2,3), (3,4), (4,5)&lt;/strong&gt;. Here&amp;#39;s the instruction:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;(map &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;partition&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; %) passwords)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Next we test each pair in the partition to see that the first value in
the pair is less than or equal to the second one:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;(map &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(every? (&lt;span style=&#34;color:#66d9ef&#34;&gt;fn &lt;/span&gt;[ [a b]] (&amp;lt;= (int a) (int b))) %) passwrods)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Pull out the ones where the above is true and count them:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;(count (filter true?))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
And that&amp;#39;s part one.&lt;/p&gt;
&lt;p&gt;
The Python equivalent would be easier to read for the non-lisper but
the idea is the same and pretty straightforward. &lt;/p&gt;
&lt;p&gt;
What I like is that we just solved a number problem without math, just
text processing.&lt;/p&gt;
&lt;p&gt;
Part 2 is more of the same. This time we still need a pair of adjacent
same digits but runs of 3 or more didn&amp;#39;t count. Now, 122234 wouldn&amp;#39;t
be a valid password because the run is of 3 while 1222344 would
because while the repeated 2s don&amp;#39;t count the 4s would.&lt;/p&gt;
&lt;p&gt;
Fortunately, this is just more text processing:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Check to make sure the sequence is increasing (as above)&lt;/li&gt;
&lt;li&gt;Remove all the sequences of 3 or more repeats. This can also be
xdone using a regular expression search and replace. In Clojure
it&amp;#39;s:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;     cleaned (&lt;span style=&#34;color:#a6e22e&#34;&gt;string/replace&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;([0-9])\1\1+&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;) 
     &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
The [0-9]\1\1+ says match any sequence of 3 or more of the same
digit and we replace it with an empty string.&lt;/li&gt;
&lt;li&gt;If the remaining string has a pair of adjacent same digits (as
above) its a valid password.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
And that&amp;#39;s it. Both parts solved as a text processing problem. What
I love here is that it seems to be a numeric problem but it has a text
based solution. Certainly something worth talking about.&lt;/p&gt;
&lt;p&gt;
Another thing I thought about as a teacher but didn&amp;#39;t pay attention to
in my solution was efficiency. My range consisted of about 500,000
values to check. Not huge enough to make a time difference but it&amp;#39;s
worth noting that there are only about 500 that fulfill the
&amp;#34;increasing&amp;#34; requirement but almost 200,000 that have a double digit
subsequence. &lt;/p&gt;
&lt;p&gt;
This means it could be more efficient to look for increasing first and
throw away most of the data and then do the digit test. This type of
ordering can be a big deal for other problems so could be worth
discussing. &lt;/p&gt;
&lt;p&gt;
Another issue is pipelining. Are you looping over the entire (or even
culled) data set over and over or can you take each number and put it
through a sequence of tests and/or transformations - the pipeline
could also lead to a more efficient solution.&lt;/p&gt;
&lt;p&gt;
Lots of good teacher fodder.&lt;/p&gt;
&lt;p&gt;
In closing I&amp;#39;ll mention one last thought - not mine but rather a
suggestion I found while perusing the Advent of Code subreddit after I
had submitted my solutions &lt;/p&gt;
&lt;p&gt;
Someone noted that since a valid number has increasing digits, if
digits appear more than once they &lt;strong&gt;have&lt;/strong&gt; to be adjacent to each
other. If they weren&amp;#39;t they&amp;#39;d violate the increasing restriction. This
means that you could solve this problem more numerically by:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;do the &amp;#34;increasing&amp;#34; test&lt;/li&gt;
&lt;li&gt;Find the sum of the counts of each digit value (0 through 9)&lt;/li&gt;
&lt;li&gt;Test to see if at least one digit appears twice.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Based on tomorrows schedule I doubt I&amp;#39;ll get to AoC day 5 but we&amp;#39;ll
see.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent 2019 Day 3</title>
      <link>https://cestlaz.github.io/post/advent-2019-day3/</link>
      <pubDate>Tue, 03 Dec 2019 19:01:13 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2019-day3/</guid>
      <description>&lt;p&gt;
Today&amp;#39;s &lt;a href=&#34;https://adventofcode.com/2019/day/3&#34;&gt;problem&lt;/a&gt; dealt with intersecting paths. You start with two
inputs, figure out the paths they represent and where they intersect
and then find the intersection that correctly answers the question.&lt;/p&gt;
&lt;p&gt;
For part 1 you have to find the intersection closest to the
origin. From a teacher&amp;#39;s point of view, the interesting part here is
data representation. This problem deals with a two dimensional grid on
which the paths live. For most students, at least in my experience, if
they&amp;#39;re trained in a language like C++ or Java they go for the direct
representation - a 2D array. For many problems this makes a lot of
sense. For this one, however, it probably doesn&amp;#39;t. We start at a
specific point but can travel in any direction for any distance. This
means we might need a crazy large array and what&amp;#39;s more, it&amp;#39;s probably
going to be sparsely filled.&lt;/p&gt;
&lt;p&gt;
A more practical solution involves maintaining a data structure with
just the individual points of interest - the points on the path. &lt;/p&gt;
&lt;p&gt;
I chose a dictionary (or hash-map or hash-table depending on language)
The key would be a tuple representing a point and the value would hold
whatever data was needed. For part one that would be a set of the
paths that went through the point. &lt;/p&gt;
&lt;p&gt;
So, if we had a path made up of 2 intersecting lines:&lt;/p&gt;
&lt;div class=&#34;src src-ditaa&#34;&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-ditaa&#34; data-lang=&#34;ditaa&#34;&gt; |
-+-----
 |&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
We could use a 2D array to represent it (assume the lines have ID&amp;#39;s 1
and 2):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&#34;align-right&#34;&gt;&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&#34;align-right&#34;&gt;0&lt;/td&gt;
&lt;td&gt;nil&lt;/td&gt;
&lt;td&gt;#{2}&lt;/td&gt;
&lt;td&gt;nil&lt;/td&gt;
&lt;td&gt;nil&lt;/td&gt;
&lt;td&gt;nil&lt;/td&gt;
&lt;td&gt;nil&lt;/td&gt;
&lt;td&gt;nil&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&#34;align-right&#34;&gt;1&lt;/td&gt;
&lt;td&gt;#{1}&lt;/td&gt;
&lt;td&gt;#{1 2}&lt;/td&gt;
&lt;td&gt;#{1}&lt;/td&gt;
&lt;td&gt;#{1}&lt;/td&gt;
&lt;td&gt;#{1}&lt;/td&gt;
&lt;td&gt;#{1}&lt;/td&gt;
&lt;td&gt;#{1}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&#34;align-right&#34;&gt;2&lt;/td&gt;
&lt;td&gt;nil&lt;/td&gt;
&lt;td&gt;#{2}&lt;/td&gt;
&lt;td&gt;nil&lt;/td&gt;
&lt;td&gt;nil&lt;/td&gt;
&lt;td&gt;nil&lt;/td&gt;
&lt;td&gt;nil&lt;/td&gt;
&lt;td&gt;nil&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
That&amp;#39;s already a good deal of wasted space. using a dictionarey we&amp;#39;d
have:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key (row,col)&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;(0,1)&lt;/td&gt;
&lt;td&gt;#{2}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(1,0)&lt;/td&gt;
&lt;td&gt;#{1}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(1,1)&lt;/td&gt;
&lt;td&gt;#{1 2}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(1,2)&lt;/td&gt;
&lt;td&gt;#{1}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(1,3)&lt;/td&gt;
&lt;td&gt;#{1}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(1,4)&lt;/td&gt;
&lt;td&gt;#{1}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(1,5()&lt;/td&gt;
&lt;td&gt;#{1}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(1,6)&lt;/td&gt;
&lt;td&gt;#{1}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(2,1)&lt;/td&gt;
&lt;td&gt;#{2}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
Which becomes much more space efficient once we go beyond the smallest
test cases.&lt;/p&gt;
&lt;p&gt;
Once we have the representation, the problem becomes one of stepping
through the paths and adding them to the dictionary. After that we can
pull out the small number of entries in our dictionary that were
visited by both paths and then we can find the final answer.&lt;/p&gt;
&lt;p&gt;
I coded this up in Clojure &lt;a href=&#34;https://github.com/zamansky/advent2019/blob/master/day03.clj&#34;&gt;(solution here)&lt;/a&gt; but forgot to account for the fact that
when a path repeats itself it shouldn&amp;#39;t count as an intersection for
the purpose of the problem. Oops. I fudged things to get the right
answer but then had to head off to Albany.&lt;/p&gt;
&lt;p&gt;
When I arrived I fixed the code but was pretty zonked so decide to
code the second part in Python &lt;a href=&#34;https://github.com/zamansky/advent2019/blob/master/day03.py&#34;&gt;(solution here)&lt;/a&gt;. Both solutions are pretty similar but
as I&amp;#39;m more comfortable with Python it didn&amp;#39;t require too much focus
to get it right.&lt;/p&gt;
&lt;p&gt;
Given the wording of this problem, I think that most people will steer
towards the type of dictionary representation I used rather than a 2D
array but this way of storing data is worth discussing with classes
when you might otherwise use a 2D array.&lt;/p&gt;
&lt;p&gt;
When might you ask?&lt;/p&gt;
&lt;p&gt;
How about something like Conway&amp;#39;s Game of Life. When this is done in a
CS1 class the world is usually represented as a 2D array. It&amp;#39;s simple
 and direct. Another approach would be to only store the live cells in
a list. You can check out a Clojurescript implementation that does
just that &lt;a href=&#34;https://github.com/zamansky/clojure-life/tree/master/src&#34;&gt;here&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;
Another would be the N-Queens problem. Insead of a board, just store
the queens locations. &lt;/p&gt;
&lt;p&gt;
Image processing? Well, there probably not. When doing image work,
you actually use all the cells in the 2D array.&lt;/p&gt;
&lt;p&gt;
That&amp;#39;s pretty much all I have to say about today&amp;#39;s problem. It got me
thinking about alternate ways of representing our data. That&amp;#39;s
something we usually don&amp;#39;t have too much of an opportunity to discuss
with our students. That&amp;#39;s unfortunate.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent 2019 Day 2</title>
      <link>https://cestlaz.github.io/post/advent-2019-day2/</link>
      <pubDate>Mon, 02 Dec 2019 17:11:43 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2019-day2/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2019/day/2&#34;&gt;Day 2&lt;/a&gt; of Advent of Code 2019 was also pretty straightforward and once
again I wrote &lt;a href=&#34;https://github.com/zamansky/advent2019/blob/master/day02.clj&#34;&gt;my solution&lt;/a&gt; in Clojure but in order to talk about this
from a teacher&amp;#39;s point of view, we&amp;#39;ll look at a &lt;a href=&#34;https://github.com/zamansky/advent2019/blob/master/day02.py&#34;&gt;Python solution&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;
At its core, this is a simulation problem - read the data into an
array or list and write a program to run through the steps. At first I
was hoping that the solution would consume the data - that is, once
you read past an instruction you don&amp;#39;t go back to it. If it was, I was
going to try to write some clever reduce. It wasn&amp;#39;t. In this problem,
any instruction could affect any part of the data set. This means you
have to keep the entire data set in memory and preferably in a random
access structure like an array. &lt;/p&gt;
&lt;p&gt;
Step 1 is to read in the data and convert it into a list of integers.
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;data  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [ int(x) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;day02.dat&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;)]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
If you don&amp;#39;t know comprehensions you can just do something like this:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;  data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;day02.dat&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;):
      data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(int(item))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Now we just have to run the simulation:&lt;/p&gt;
&lt;p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-pythonf&#34; data-lang=&#34;pythonf&#34;&gt;def run_program(program):
    ip = 0
    while True:
        op = program[ip]
        if op == 99:
            break
        a = program[ program[ip+1] ]
        b = program[ program[ip+2] ]
        dest = program[ip+3]
        if op == 1:
            program[dest] =  a + b
        else:
            program[dest] = a * b
        ip = ip + 4
    return program[0]

def part1(program):
    program[1]=12
    program[2]=2
    return run_program((program))&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;
The most likely source of error here is forgetting to change the
values in &lt;code&gt;program[1]&lt;/code&gt; and &lt;code&gt;program[2]&lt;/code&gt; in lines 18 and 19 as
specified in the question. The other likely error is forgetting to do
the two level indirection in lines 7 and 8. That is writing
&lt;code&gt;program[ip+1]&lt;/code&gt; and &lt;code&gt;program[ip+2]&lt;/code&gt; by mistake. Truth be told, I made
both of these mistakes but I didn&amp;#39;t find them to be &amp;#34;interesting&amp;#34;
mistakes. &lt;/p&gt;
&lt;p&gt;
The interesting part of this program is part 2 where instead of
setting &lt;code&gt;program[1]&lt;/code&gt; to &lt;code&gt;12&lt;/code&gt; and &lt;code&gt;program[2]&lt;/code&gt; to &lt;code&gt;2&lt;/code&gt; you have to try
values between 0 and 99 inclusive for each entry until you find a
specific answer. &lt;/p&gt;
&lt;p&gt;
This is a great platform to talk about memory. The problem refers to
the values you put into &lt;code&gt;program[1]&lt;/code&gt; as &lt;strong&gt;nouns&lt;/strong&gt; and &lt;code&gt;program[2]&lt;/code&gt; as
&lt;strong&gt;verbs&lt;/strong&gt;. The issue is that every time you run your program for a
specific &lt;strong&gt;noun verb&lt;/strong&gt; combination you change the array (list)
representing your program. If you don&amp;#39;t reset the array to its
original contents before the next run, the next run will be working
off of new values and therefore give you incorrect results. &lt;/p&gt;
&lt;p&gt;
This is a great platform for discussion. Students usually start with
&lt;strong&gt;pass by value&lt;/strong&gt; semantics so passing a list to a function and then
having the list change can seem weird even though it can still be pass
by value:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# bad example to follow&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;change_list&lt;/span&gt;(l):
      l[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9999&lt;/span&gt;

  l&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;]
  change_list(l)
  &lt;span style=&#34;color:#75715e&#34;&gt;# changes l[3] to 9999&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Here&amp;#39;s a finished solution:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1&lt;/span&gt;data  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [ int(x) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;day02.dat&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;)]
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2&lt;/span&gt;
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run_program&lt;/span&gt;(program):
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4&lt;/span&gt;    ip &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;:
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6&lt;/span&gt;        op &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; program[ip]
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; op &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;99&lt;/span&gt;:
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9&lt;/span&gt;        a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; program[ program[ip&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] ]
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10&lt;/span&gt;        b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; program[ program[ip&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] ]
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11&lt;/span&gt;        dest &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; program[ip&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; op &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13&lt;/span&gt;            program[dest] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;  a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;14&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;15&lt;/span&gt;            program[dest] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; b
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;16&lt;/span&gt;        ip &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ip &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;17&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; program[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;18&lt;/span&gt;
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;19&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;part1&lt;/span&gt;(data):
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;20&lt;/span&gt;    program &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; data[:]
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;21&lt;/span&gt;    program[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;22&lt;/span&gt;    program[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;23&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; run_program((program))
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;24&lt;/span&gt;
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;25&lt;/span&gt;
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;26&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;part2&lt;/span&gt;(data):
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;27&lt;/span&gt;    results &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;28&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; noun &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;):
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;29&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; verb &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;):
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;30&lt;/span&gt;            program &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; data[:]
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;31&lt;/span&gt;            program[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; noun
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;32&lt;/span&gt;            program[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; verb
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;33&lt;/span&gt;            r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; run_program(program)
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;34&lt;/span&gt;            results&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append( (&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;noun&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;verb, r))
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;35&lt;/span&gt;    ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [ x &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; results &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;19690720&lt;/span&gt;]
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;36&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;37&lt;/span&gt;    
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;38&lt;/span&gt;print(part1(data))
&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;39&lt;/span&gt;print(part2(data))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Note that in line 30 we copy over the original data for each noun,verb
combo. also note the list comprehension in line 35 to find the final
answer. &lt;/p&gt;
&lt;p&gt;
One last potential error point is notice that we had to add the array
copy in line 20. Otherwise part1 will change the data and if we run it
before part2 we won&amp;#39;t get the correct result.&lt;/p&gt;
&lt;p&gt;
So there it is. Another nice problem and even though it&amp;#39;s a
straightforward problem, there&amp;#39;s still some interesting meat to
discuss with your students.&lt;/p&gt;
&lt;p&gt;
Tomorrow, snowstorm notwithstanding, I&amp;#39;ll be heading up to Albany for
the remainder of the week so might not be able to get to day 3 and
beyond until Friday so who knows if I&amp;#39;ll post any more of these
write ups.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2019 Day 1</title>
      <link>https://cestlaz.github.io/post/advent-2019-day1/</link>
      <pubDate>Sun, 01 Dec 2019 14:23:35 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2019-day1/</guid>
      <description>&lt;p&gt;
Like most programming challenges, &lt;a href=&#34;http://adventofcode.com&#34;&gt;Advent of Code&lt;/a&gt; ramps out from
easier, more accessible problems to harder, more complex ones. As
such, a number of the early challenges are great problems for early CS
students. &lt;/p&gt;
&lt;p&gt;
I thought that while I watched my NY Giants play valiantly in their
attempt to get a high draft pick I&amp;#39;d talk about today&amp;#39;s &lt;a href=&#34;https://adventofcode.com/2019/day/1&#34;&gt;challenge&lt;/a&gt;
from a teacher&amp;#39;s point of view.&lt;/p&gt;
&lt;p&gt;
The summary of part one is that you have a list of inputs (masses of
components) and for each one you have to perform a calculation (how
much fuel is needed). The answer will be the sum of the fuels.&lt;/p&gt;
&lt;p&gt;
The most challenging part of this for a beginner might be reading in
the data but that&amp;#39;s not too much of a challenge:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;day01.dat&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;readlines()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Now we can calculate part1:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;  data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;day01.dat&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;readlines()

  sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; mass &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
      sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; int(mass)&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
  print(sum)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Part 2 adds a twist. Now, you have to also consider the fuel needed
for the fuel you&amp;#39;ve added. Basically, you have to calculate how much
fuel you&amp;#39;ll need for a given item and then how much fuel you&amp;#39;ll need
for that fuel. You repeat this until the amount of fuel you need is
either 0 or negative. See &lt;a href=&#34;https://adventofcode.com/2019/day/1&#34;&gt;the challenge&lt;/a&gt; for more info on this. &lt;/p&gt;
&lt;p&gt;
This is our first &amp;#34;teaching moment.&amp;#34; This is going to be messy to work
into our part1 solution but if we had factored out the original fuel
calculation we could probably reused it and maybe more of our
solution:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;  data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;day01.dat&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;readlines()

  &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;calc_fuel&lt;/span&gt;(mass):
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; int(mass)&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;

  sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; mass &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
      sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; calc_fuel(mass)
  print(sum)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
Now we can just add an inner loop that repeatedly adds the fuel costs.&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;  data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;day01.dat&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;readlines()

  &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;calc_fuel&lt;/span&gt;(mass):
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; int(mass)&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;

  sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; mass &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
      fuel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; calc_fuel(mass)
      &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; fuel &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
          sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; fuel
          fuel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;  calc_fuel(fuel)
  print(sum)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
More &amp;#34;teachable moments.&amp;#34; We have to change up variables in our fuel
calculations (lines 8 and 11) and for a beginner, the loop within a
loop can be somewhat muddled. It&amp;#39;s more complex but it&amp;#39;s doing
something that &lt;strong&gt;is&lt;/strong&gt; more complex. It&amp;#39;s also good nested loop practice.&lt;/p&gt;
&lt;p&gt;
For more advanced students, if they&amp;#39;re familiar with list
comprehensions you can really clean up part 1:&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;  data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;day01.dat&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;readlines()
  data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [int(x) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data] &lt;span style=&#34;color:#75715e&#34;&gt;# convert to ints before starting&lt;/span&gt;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;calc_fuel&lt;/span&gt;(mass):
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; mass&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;

  &lt;span style=&#34;color:#75715e&#34;&gt;# part 1&lt;/span&gt;
  part1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum([calc_fuel(x) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;
but I think part 2 either stay&amp;#39;s more or less as is.&lt;/p&gt;
&lt;p&gt;
Personally, I wrote my solutions in Clojure:&lt;/p&gt;
&lt;div class=&#34;src src-clojure&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;ns &lt;/span&gt;day01
  (&lt;span style=&#34;color:#e6db74&#34;&gt;:require&lt;/span&gt; [clojure.string &lt;span style=&#34;color:#e6db74&#34;&gt;:as&lt;/span&gt; string]
            [utils &lt;span style=&#34;color:#e6db74&#34;&gt;:as&lt;/span&gt; u]))


(&lt;span style=&#34;color:#66d9ef&#34;&gt;def &lt;/span&gt;test-masses [&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;14&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1969&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100756&lt;/span&gt;])

&lt;span style=&#34;color:#75715e&#34;&gt;;; load data&lt;/span&gt;
(&lt;span style=&#34;color:#66d9ef&#34;&gt;def &lt;/span&gt;masses (&lt;span style=&#34;color:#a6e22e&#34;&gt;-&amp;gt;&amp;gt;&lt;/span&gt;
             (slurp &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;day01.dat&amp;#34;&lt;/span&gt;)
             string/split-lines
             (map u/parse-int)
             ))


(&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;calc-mass-part1 [mass]
  (- (quot mass &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;))

(&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;part1 [masses]
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;calculate fuel for each mass then sum them all&amp;#34;&lt;/span&gt;
  (reduce + (map calc-mass-part1 masses)))



(&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;calc-mass-part2
  ([mass] (&lt;span style=&#34;color:#a6e22e&#34;&gt;calc-mass-part2&lt;/span&gt; mass &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;))
  ([mass cost]
   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Same as part 1 but loop to calculate fuel for the fuel&amp;#34;&lt;/span&gt;
   (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;[fuel (&lt;span style=&#34;color:#a6e22e&#34;&gt;calc-mass-part1&lt;/span&gt; mass)]
     (&lt;span style=&#34;color:#66d9ef&#34;&gt;if &lt;/span&gt;(&amp;lt;= fuel &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
       cost
       (&lt;span style=&#34;color:#a6e22e&#34;&gt;recur&lt;/span&gt; fuel (+ cost fuel))))))
  
(&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;part2 [masses]
  (reduce + (map calc-mass-part2 masses )))

(&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;main []
(println (str &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Part1: &amp;#34;&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;part1&lt;/span&gt; masses)))
(println (str &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Part2: &amp;#34;&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;part2&lt;/span&gt; masses)))
)

(&lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
So that&amp;#39;s day 1. I don&amp;#39;t know if I&amp;#39;ll write up any more or, given my
travel and work schedule for the week,if I&amp;#39;ll even be able  to work
on more problems until next weekend. &lt;/p&gt;
&lt;p&gt;
In any event. If you&amp;#39;re teaching CS0 or CS1 students, you should
really check out Advent of Code.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>